import{_ as n,C as o,c as d,o as p,j as e,a,aA as r,G as t,w as l}from"./chunks/framework.BA5u_Yub.js";const si=JSON.parse('{"title":"Modules","description":"","frontmatter":{},"headers":[],"relativePath":"lib/modules.md","filePath":"lib/modules.md","lastUpdated":null}'),h={name:"lib/modules.md"},c={class:"jldocstring custom-block",open:""},u={class:"jldocstring custom-block",open:""},k={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},T={class:"jldocstring custom-block",open:""},C={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""},_={class:"jldocstring custom-block",open:""},j={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""},A={class:"jldocstring custom-block",open:""},v={class:"jldocstring custom-block",open:""},F={class:"jldocstring custom-block",open:""},N={class:"jldocstring custom-block",open:""},x={class:"jldocstring custom-block",open:""},S={class:"jldocstring custom-block",open:""},D={class:"jldocstring custom-block",open:""},I={class:"jldocstring custom-block",open:""},P={class:"jldocstring custom-block",open:""},G={class:"jldocstring custom-block",open:""},V={class:"jldocstring custom-block",open:""},O={class:"jldocstring custom-block",open:""},L={class:"jldocstring custom-block",open:""},B={class:"jldocstring custom-block",open:""},w={class:"jldocstring custom-block",open:""},M={class:"jldocstring custom-block",open:""},U={class:"jldocstring custom-block",open:""},R={class:"jldocstring custom-block",open:""},z={class:"jldocstring custom-block",open:""},K={class:"jldocstring custom-block",open:""},q={class:"jldocstring custom-block",open:""},W={class:"jldocstring custom-block",open:""},$={class:"jldocstring custom-block",open:""},Z={class:"jldocstring custom-block",open:""},J={class:"jldocstring custom-block",open:""},H={class:"jldocstring custom-block",open:""},Q={class:"jldocstring custom-block",open:""},X={class:"jldocstring custom-block",open:""},Y={class:"jldocstring custom-block",open:""},ss={class:"jldocstring custom-block",open:""},es={class:"jldocstring custom-block",open:""},is={class:"jldocstring custom-block",open:""},ts={class:"jldocstring custom-block",open:""},as={class:"jldocstring custom-block",open:""},ls={class:"jldocstring custom-block",open:""},rs={class:"jldocstring custom-block",open:""},ns={class:"jldocstring custom-block",open:""},os={class:"jldocstring custom-block",open:""},ds={class:"jldocstring custom-block",open:""},ps={class:"jldocstring custom-block",open:""},hs={class:"jldocstring custom-block",open:""},cs={class:"jldocstring custom-block",open:""},us={class:"jldocstring custom-block",open:""},ks={class:"jldocstring custom-block",open:""},gs={class:"jldocstring custom-block",open:""},ys={class:"jldocstring custom-block",open:""},bs={class:"jldocstring custom-block",open:""},ms={class:"jldocstring custom-block",open:""},Ts={class:"jldocstring custom-block",open:""},Cs={class:"jldocstring custom-block",open:""},fs={class:"jldocstring custom-block",open:""},_s={class:"jldocstring custom-block",open:""},js={class:"jldocstring custom-block",open:""},Es={class:"jldocstring custom-block",open:""},As={class:"jldocstring custom-block",open:""},vs={class:"jldocstring custom-block",open:""},Fs={class:"jldocstring custom-block",open:""},Ns={class:"jldocstring custom-block",open:""},xs={class:"jldocstring custom-block",open:""},Ss={class:"jldocstring custom-block",open:""},Ds={class:"jldocstring custom-block",open:""},Is={class:"jldocstring custom-block",open:""},Ps={class:"jldocstring custom-block",open:""},Gs={class:"jldocstring custom-block",open:""},Vs={class:"jldocstring custom-block",open:""},Os={class:"jldocstring custom-block",open:""},Ls={class:"jldocstring custom-block",open:""},Bs={class:"jldocstring custom-block",open:""},ws={class:"jldocstring custom-block",open:""},Ms={class:"jldocstring custom-block",open:""},Us={class:"jldocstring custom-block",open:""},Rs={class:"jldocstring custom-block",open:""},zs={class:"jldocstring custom-block",open:""},Ks={class:"jldocstring custom-block",open:""},qs={class:"jldocstring custom-block",open:""},Ws={class:"jldocstring custom-block",open:""},$s={class:"jldocstring custom-block",open:""},Zs={class:"jldocstring custom-block",open:""},Js={class:"jldocstring custom-block",open:""},Hs={class:"jldocstring custom-block",open:""},Qs={class:"jldocstring custom-block",open:""},Xs={class:"jldocstring custom-block",open:""},Ys={class:"jldocstring custom-block",open:""},se={class:"jldocstring custom-block",open:""},ee={class:"jldocstring custom-block",open:""},ie={class:"jldocstring custom-block",open:""},te={class:"jldocstring custom-block",open:""},ae={class:"jldocstring custom-block",open:""},le={class:"jldocstring custom-block",open:""},re={class:"jldocstring custom-block",open:""},ne={class:"jldocstring custom-block",open:""},oe={class:"jldocstring custom-block",open:""},de={class:"jldocstring custom-block",open:""},pe={class:"jldocstring custom-block",open:""},he={class:"jldocstring custom-block",open:""},ce={class:"jldocstring custom-block",open:""},ue={class:"jldocstring custom-block",open:""},ke={class:"jldocstring custom-block",open:""},ge={class:"jldocstring custom-block",open:""},ye={class:"jldocstring custom-block",open:""},be={class:"jldocstring custom-block",open:""},me={class:"jldocstring custom-block",open:""},Te={class:"jldocstring custom-block",open:""},Ce={class:"jldocstring custom-block",open:""},fe={class:"jldocstring custom-block",open:""},_e={class:"jldocstring custom-block",open:""},je={class:"jldocstring custom-block",open:""},Ee={class:"jldocstring custom-block",open:""},Ae={class:"jldocstring custom-block",open:""},ve={class:"jldocstring custom-block",open:""},Fe={class:"jldocstring custom-block",open:""},Ne={class:"jldocstring custom-block",open:""},xe={class:"jldocstring custom-block",open:""},Se={class:"jldocstring custom-block",open:""},De={class:"jldocstring custom-block",open:""},Ie={class:"jldocstring custom-block",open:""},Pe={class:"jldocstring custom-block",open:""},Ge={class:"jldocstring custom-block",open:""},Ve={class:"jldocstring custom-block",open:""},Oe={class:"jldocstring custom-block",open:""},Le={class:"jldocstring custom-block",open:""},Be={class:"jldocstring custom-block",open:""},we={class:"jldocstring custom-block",open:""},Me={class:"jldocstring custom-block",open:""},Ue={class:"jldocstring custom-block",open:""},Re={class:"jldocstring custom-block",open:""},ze={class:"jldocstring custom-block",open:""},Ke={class:"jldocstring custom-block",open:""},qe={class:"jldocstring custom-block",open:""},We={class:"jldocstring custom-block",open:""};function $e(Ze,s,Je,He,Qe,Xe){const i=o("Badge");return p(),d("div",null,[s[578]||(s[578]=e("h1",{id:"modules",tabindex:"-1"},[a("Modules "),e("a",{class:"header-anchor",href:"#modules","aria-label":'Permalink to "Modules"'},"​")],-1)),s[579]||(s[579]=e("h2",{id:"grids",tabindex:"-1"},[a("Grids "),e("a",{class:"header-anchor",href:"#grids","aria-label":'Permalink to "Grids"'},"​")],-1)),e("details",c,[e("summary",null,[s[0]||(s[0]=e("a",{id:"Chmy.Grids.AbstractAxis",href:"#Chmy.Grids.AbstractAxis"},[e("span",{class:"jlbinding"},"Chmy.Grids.AbstractAxis")],-1)),s[1]||(s[1]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[3]||(s[3]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">abstract type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AbstractAxis{T}</span></span></code></pre></div><p>Abstract type representing an axis in a grid, where the axis is parameterized by the type <code>T</code> of the coordinates.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[2]||(s[2]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/abstract_axis.jl#L1-L5",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",u,[e("summary",null,[s[4]||(s[4]=e("a",{id:"Chmy.Grids.Center",href:"#Chmy.Grids.Center"},[e("span",{class:"jlbinding"},"Chmy.Grids.Center")],-1)),s[5]||(s[5]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[7]||(s[7]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Center </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Location</span></span></code></pre></div><p>The <code>Center</code> struct represents a location at the center along a dimension of a grid cell.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[6]||(s[6]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/Grids.jl#L28-L32",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",k,[e("summary",null,[s[8]||(s[8]=e("a",{id:"Chmy.Grids.Connectivity",href:"#Chmy.Grids.Connectivity"},[e("span",{class:"jlbinding"},"Chmy.Grids.Connectivity")],-1)),s[9]||(s[9]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[11]||(s[11]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">abstract type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Connectivity</span></span></code></pre></div><p>Abstract type representing the connectivity of grid elements.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[10]||(s[10]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/Grids.jl#L47-L51",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",g,[e("summary",null,[s[12]||(s[12]=e("a",{id:"Chmy.Grids.Location",href:"#Chmy.Grids.Location"},[e("span",{class:"jlbinding"},"Chmy.Grids.Location")],-1)),s[13]||(s[13]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[15]||(s[15]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">abstract type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Location</span></span></code></pre></div><p>Abstract type representing a location in a grid cell.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[14]||(s[14]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/Grids.jl#L21-L25",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",y,[e("summary",null,[s[16]||(s[16]=e("a",{id:"Chmy.Grids.StructuredGrid",href:"#Chmy.Grids.StructuredGrid"},[e("span",{class:"jlbinding"},"Chmy.Grids.StructuredGrid")],-1)),s[17]||(s[17]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[19]||(s[19]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">StructuredGrid</span></span></code></pre></div><p>Represents a structured grid with orthogonal axes.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[18]||(s[18]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/structured_grid.jl#L1-L5",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",b,[e("summary",null,[s[20]||(s[20]=e("a",{id:"Chmy.Grids.UniformGrid-Union{Tuple{Architecture}, Tuple{N}} where N",href:"#Chmy.Grids.UniformGrid-Union{Tuple{Architecture}, Tuple{N}} where N"},[e("span",{class:"jlbinding"},"Chmy.Grids.UniformGrid")],-1)),s[21]||(s[21]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[23]||(s[23]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UniformGrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arch; origin, extent, dims, topology</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Constructs a uniform grid with specified origin, extent, dimensions, and topology.</p><p><strong>Arguments</strong></p><ul><li><p><code>arch::Architecture</code>: The associated architecture.</p></li><li><p><code>origin::NTuple{N,Number}</code>: The origin of the grid.</p></li><li><p><code>extent::NTuple{N,Number}</code>: The extent of the grid.</p></li><li><p><code>dims::NTuple{N,Integer}</code>: The dimensions of the grid.</p></li><li><p><code>topology=nothing</code>: The topology of the grid. If not provided, a default <code>Bounded</code> topology is used.</p></li></ul>',4)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[22]||(s[22]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/structured_grid.jl#L15-L26",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",m,[e("summary",null,[s[24]||(s[24]=e("a",{id:"Chmy.Grids.Vertex",href:"#Chmy.Grids.Vertex"},[e("span",{class:"jlbinding"},"Chmy.Grids.Vertex")],-1)),s[25]||(s[25]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[27]||(s[27]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vertex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Location</span></span></code></pre></div><p>The <code>Vertex</code> struct represents a location at the vertex along a dimension of a grid cell.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[26]||(s[26]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/Grids.jl#L35-L39",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",T,[e("summary",null,[s[28]||(s[28]=e("a",{id:"Chmy.Grids.axes_names-Tuple{StructuredGrid{1}}",href:"#Chmy.Grids.axes_names-Tuple{StructuredGrid{1}}"},[e("span",{class:"jlbinding"},"Chmy.Grids.axes_names")],-1)),s[29]||(s[29]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[31]||(s[31]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">axes_names</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SG{1}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Returns the names of the axes for a 1-dimensional structured grid.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[30]||(s[30]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/structured_grid.jl#L226-L230",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",C,[e("summary",null,[s[32]||(s[32]=e("a",{id:"Chmy.Grids.axes_names-Tuple{StructuredGrid{2}}",href:"#Chmy.Grids.axes_names-Tuple{StructuredGrid{2}}"},[e("span",{class:"jlbinding"},"Chmy.Grids.axes_names")],-1)),s[33]||(s[33]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[35]||(s[35]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">axes_names</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SG{2}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Returns the names of the axes for a 2-dimensional structured grid.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[34]||(s[34]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/structured_grid.jl#L233-L237",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",f,[e("summary",null,[s[36]||(s[36]=e("a",{id:"Chmy.Grids.axes_names-Tuple{StructuredGrid{3}}",href:"#Chmy.Grids.axes_names-Tuple{StructuredGrid{3}}"},[e("span",{class:"jlbinding"},"Chmy.Grids.axes_names")],-1)),s[37]||(s[37]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[39]||(s[39]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">axes_names</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SG{3}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Returns the names of the axes for a 3-dimensional structured grid.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[38]||(s[38]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/structured_grid.jl#L240-L244",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",_,[e("summary",null,[s[40]||(s[40]=e("a",{id:"Chmy.Grids.axis-Union{Tuple{dim}, Tuple{StructuredGrid, Dim{dim}}} where dim",href:"#Chmy.Grids.axis-Union{Tuple{dim}, Tuple{StructuredGrid, Dim{dim}}} where dim"},[e("span",{class:"jlbinding"},"Chmy.Grids.axis")],-1)),s[41]||(s[41]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[43]||(s[43]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">axis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid, dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return the axis corresponding to the spatial dimension <code>dim</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[42]||(s[42]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/structured_grid.jl#L86-L90",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",j,[e("summary",null,[s[44]||(s[44]=e("a",{id:"Chmy.Grids.bounds-Union{Tuple{N}, Tuple{StructuredGrid{N}, Union{NTuple{N, Location}, Location}}} where N",href:"#Chmy.Grids.bounds-Union{Tuple{N}, Tuple{StructuredGrid{N}, Union{NTuple{N, Location}, Location}}} where N"},[e("span",{class:"jlbinding"},"Chmy.Grids.bounds")],-1)),s[45]||(s[45]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[47]||(s[47]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bounds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid, loc, [dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span></code></pre></div><p>Return the bounds of a structured grid at the specified location(s).</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[46]||(s[46]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/structured_grid.jl#L59-L63",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",E,[e("summary",null,[s[48]||(s[48]=e("a",{id:"Chmy.Grids.connectivity-Union{Tuple{S}, Tuple{D}, Tuple{C}, Tuple{T}, Tuple{N}, Tuple{StructuredGrid{N, T, C}, Dim{D}, Side{S}}} where {N, T, C, D, S}",href:"#Chmy.Grids.connectivity-Union{Tuple{S}, Tuple{D}, Tuple{C}, Tuple{T}, Tuple{N}, Tuple{StructuredGrid{N, T, C}, Dim{D}, Side{S}}} where {N, T, C, D, S}"},[e("span",{class:"jlbinding"},"Chmy.Grids.connectivity")],-1)),s[49]||(s[49]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[51]||(s[51]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">connectivity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid, dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, side</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Side</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return the connectivity of the structured grid <code>grid</code> for the given dimension <code>dim</code> and side <code>side</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[50]||(s[50]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/structured_grid.jl#L52-L56",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",A,[e("summary",null,[s[52]||(s[52]=e("a",{id:"Chmy.Grids.coord-Union{Tuple{N}, Tuple{StructuredGrid{N}, Location, Vararg{Integer, N}}} where N",href:"#Chmy.Grids.coord-Union{Tuple{N}, Tuple{StructuredGrid{N}, Location, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.Grids.coord")],-1)),s[53]||(s[53]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[55]||(s[55]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">coord</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid, loc, I</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return a tuple of spatial coordinates of a grid point at location <code>loc</code> and indices <code>I</code>.</p><p>For vertex locations, first grid point is at the origin. For center locations, first grid point at half-spacing distance from the origin.</p>',3)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[54]||(s[54]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/structured_grid.jl#L95-L102",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",v,[e("summary",null,[s[56]||(s[56]=e("a",{id:"Chmy.Grids.extent-Union{Tuple{N}, Tuple{StructuredGrid{N}, Union{NTuple{N, Location}, Location}}} where N",href:"#Chmy.Grids.extent-Union{Tuple{N}, Tuple{StructuredGrid{N}, Union{NTuple{N, Location}, Location}}} where N"},[e("span",{class:"jlbinding"},"Chmy.Grids.extent")],-1)),s[57]||(s[57]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[59]||(s[59]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">extent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid, loc, [dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span></code></pre></div><p>Return the extent of a structured grid at the specified location(s).</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[58]||(s[58]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/structured_grid.jl#L68-L72",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",F,[e("summary",null,[s[60]||(s[60]=e("a",{id:"Chmy.Grids.inv_spacing-Union{Tuple{N}, Tuple{StructuredGrid{N}, Location, Vararg{Integer, N}}} where N",href:"#Chmy.Grids.inv_spacing-Union{Tuple{N}, Tuple{StructuredGrid{N}, Location, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.Grids.inv_spacing")],-1)),s[61]||(s[61]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[63]||(s[63]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">inv_spacing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid, loc, I</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return a tuple of inverse grid spacings at location <code>loc</code> and indices <code>I</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[62]||(s[62]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/structured_grid.jl#L131-L135",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",N,[e("summary",null,[s[64]||(s[64]=e("a",{id:"Chmy.Grids.inv_spacing-Union{Tuple{UniformGrid{N}}, Tuple{N}} where N",href:"#Chmy.Grids.inv_spacing-Union{Tuple{UniformGrid{N}}, Tuple{N}} where N"},[e("span",{class:"jlbinding"},"Chmy.Grids.inv_spacing")],-1)),s[65]||(s[65]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[67]||(s[67]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">inv_spacing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UniformGrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return a tuple of inverse grid spacing for a uniform grid <code>grid</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[66]||(s[66]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/structured_grid.jl#L164-L168",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",x,[e("summary",null,[s[68]||(s[68]=e("a",{id:"Chmy.Grids.inv_volume-Union{Tuple{N}, Tuple{StructuredGrid{N}, NTuple{N, Location}, Vararg{Integer, N}}} where N",href:"#Chmy.Grids.inv_volume-Union{Tuple{N}, Tuple{StructuredGrid{N}, NTuple{N, Location}, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.Grids.inv_volume")],-1)),s[69]||(s[69]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[71]||(s[71]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">inv_volume</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid, loc, I</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return the inverse of control volume at location <code>loc</code> and indices <code>I</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[70]||(s[70]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/structured_grid.jl#L250-L254",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",S,[e("summary",null,[s[72]||(s[72]=e("a",{id:"Chmy.Grids.iΔ",href:"#Chmy.Grids.iΔ"},[e("span",{class:"jlbinding"},"Chmy.Grids.iΔ")],-1)),s[73]||(s[73]=a()),t(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[75]||(s[75]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">iΔ</span></span></code></pre></div><p>Alias for the <code>inv_spacing</code> method that returns the reciprocal of the spacing between grid points.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[74]||(s[74]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/Grids.jl#L74-L78",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",D,[e("summary",null,[s[76]||(s[76]=e("a",{id:"Chmy.Grids.origin-Union{Tuple{N}, Tuple{StructuredGrid{N}, Union{NTuple{N, Location}, Location}}} where N",href:"#Chmy.Grids.origin-Union{Tuple{N}, Tuple{StructuredGrid{N}, Union{NTuple{N, Location}, Location}}} where N"},[e("span",{class:"jlbinding"},"Chmy.Grids.origin")],-1)),s[77]||(s[77]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[79]||(s[79]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">origin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid, loc, [dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span></code></pre></div><p>Return the origin of a structured grid at the specified location(s).</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[78]||(s[78]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/structured_grid.jl#L77-L81",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",I,[e("summary",null,[s[80]||(s[80]=e("a",{id:"Chmy.Grids.spacing-Union{Tuple{N}, Tuple{StructuredGrid{N}, Location, Vararg{Integer, N}}} where N",href:"#Chmy.Grids.spacing-Union{Tuple{N}, Tuple{StructuredGrid{N}, Location, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.Grids.spacing")],-1)),s[81]||(s[81]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[83]||(s[83]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">spacing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid, loc, I</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return a tuple of grid spacings at location <code>loc</code> and indices <code>I</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[82]||(s[82]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/structured_grid.jl#L131-L135",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",P,[e("summary",null,[s[84]||(s[84]=e("a",{id:"Chmy.Grids.spacing-Union{Tuple{UniformGrid{N}}, Tuple{N}} where N",href:"#Chmy.Grids.spacing-Union{Tuple{UniformGrid{N}}, Tuple{N}} where N"},[e("span",{class:"jlbinding"},"Chmy.Grids.spacing")],-1)),s[85]||(s[85]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[87]||(s[87]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">spacing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UniformGrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return a tuple of grid spacing for a uniform grid <code>grid</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[86]||(s[86]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/structured_grid.jl#L156-L160",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",G,[e("summary",null,[s[88]||(s[88]=e("a",{id:"Chmy.Grids.volume-Union{Tuple{N}, Tuple{StructuredGrid{N}, NTuple{N, Location}, Vararg{Integer, N}}} where N",href:"#Chmy.Grids.volume-Union{Tuple{N}, Tuple{StructuredGrid{N}, NTuple{N, Location}, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.Grids.volume")],-1)),s[89]||(s[89]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[91]||(s[91]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">volume</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid, loc, I</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return the control volume at location <code>loc</code> and indices <code>I</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[90]||(s[90]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/structured_grid.jl#L250-L254",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",V,[e("summary",null,[s[92]||(s[92]=e("a",{id:"Chmy.Grids.Δ",href:"#Chmy.Grids.Δ"},[e("span",{class:"jlbinding"},"Chmy.Grids.Δ")],-1)),s[93]||(s[93]=a()),t(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[95]||(s[95]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Δ</span></span></code></pre></div><p>Alias for the <code>spacing</code> method that returns the spacing between grid points.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[94]||(s[94]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Grids/Grids.jl#L67-L71",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[580]||(s[580]=e("h2",{id:"architectures",tabindex:"-1"},[a("Architectures "),e("a",{class:"header-anchor",href:"#architectures","aria-label":'Permalink to "Architectures"'},"​")],-1)),e("details",O,[e("summary",null,[s[96]||(s[96]=e("a",{id:"Chmy.Architectures.Architecture",href:"#Chmy.Architectures.Architecture"},[e("span",{class:"jlbinding"},"Chmy.Architectures.Architecture")],-1)),s[97]||(s[97]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[99]||(s[99]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Architecture</span></span></code></pre></div><p>Abstract type representing an architecture.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[98]||(s[98]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Architectures.jl#L9-L13",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",L,[e("summary",null,[s[100]||(s[100]=e("a",{id:"Chmy.Architectures.SingleDeviceArchitecture",href:"#Chmy.Architectures.SingleDeviceArchitecture"},[e("span",{class:"jlbinding"},"Chmy.Architectures.SingleDeviceArchitecture")],-1)),s[101]||(s[101]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[103]||(s[103]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SingleDeviceArchitecture </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Architecture</span></span></code></pre></div><p>A struct representing an architecture that operates on a single CPU or GPU device.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[102]||(s[102]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Architectures.jl#L16-L20",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",B,[e("summary",null,[s[104]||(s[104]=e("a",{id:"Chmy.Architectures.SingleDeviceArchitecture-Tuple{Architecture}",href:"#Chmy.Architectures.SingleDeviceArchitecture-Tuple{Architecture}"},[e("span",{class:"jlbinding"},"Chmy.Architectures.SingleDeviceArchitecture")],-1)),s[105]||(s[105]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[107]||(s[107]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SingleDeviceArchitecture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Architecture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a <code>SingleDeviceArchitecture</code> object retrieving backend and device from <code>arch</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[106]||(s[106]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Architectures.jl#L30-L34",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",w,[e("summary",null,[s[108]||(s[108]=e("a",{id:"Chmy.Architectures.Arch-Tuple{KernelAbstractions.Backend}",href:"#Chmy.Architectures.Arch-Tuple{KernelAbstractions.Backend}"},[e("span",{class:"jlbinding"},"Chmy.Architectures.Arch")],-1)),s[109]||(s[109]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[111]||(s[111]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Arch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Backend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; device_id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create an architecture object for the specified backend and device.</p><p><strong>Arguments</strong></p><ul><li><p><code>backend</code>: The backend to use for computation.</p></li><li><p><code>device_id=1</code>: The ID of the device to use.</p></li></ul>',4)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[110]||(s[110]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Architectures.jl#L37-L45",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",M,[e("summary",null,[s[112]||(s[112]=e("a",{id:"Chmy.Architectures.activate!-Tuple{SingleDeviceArchitecture}",href:"#Chmy.Architectures.activate!-Tuple{SingleDeviceArchitecture}"},[e("span",{class:"jlbinding"},"Chmy.Architectures.activate!")],-1)),s[113]||(s[113]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[115]||(s[115]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">activate!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SingleDeviceArchitecture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; priority</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:normal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Activate the given architecture on the specified device and set the priority of the backend. For the priority accepted values are <code>:normal</code>, <code>:low</code> and <code>:high</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[114]||(s[114]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Architectures.jl#L65-L70",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",U,[e("summary",null,[s[116]||(s[116]=e("a",{id:"Chmy.Architectures.get_device-Tuple{SingleDeviceArchitecture}",href:"#Chmy.Architectures.get_device-Tuple{SingleDeviceArchitecture}"},[e("span",{class:"jlbinding"},"Chmy.Architectures.get_device")],-1)),s[117]||(s[117]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[119]||(s[119]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_device</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SingleDeviceArchitecture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the device associated with a SingleDeviceArchitecture.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[118]||(s[118]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Architectures.jl#L58-L62",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",R,[e("summary",null,[s[120]||(s[120]=e("a",{id:"KernelAbstractions.get_backend-Tuple{SingleDeviceArchitecture}",href:"#KernelAbstractions.get_backend-Tuple{SingleDeviceArchitecture}"},[e("span",{class:"jlbinding"},"KernelAbstractions.get_backend")],-1)),s[121]||(s[121]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[123]||(s[123]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_backend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SingleDeviceArchitecture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the backend associated with a SingleDeviceArchitecture.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[122]||(s[122]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Architectures.jl#L51-L55",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[581]||(s[581]=e("h2",{id:"fields",tabindex:"-1"},[a("Fields "),e("a",{class:"header-anchor",href:"#fields","aria-label":'Permalink to "Fields"'},"​")],-1)),e("details",z,[e("summary",null,[s[124]||(s[124]=e("a",{id:"Chmy.Fields.AbstractField",href:"#Chmy.Fields.AbstractField"},[e("span",{class:"jlbinding"},"Chmy.Fields.AbstractField")],-1)),s[125]||(s[125]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[127]||(s[127]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">abstract type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AbstractField{T,N,L} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractArray{T,N}</span></span></code></pre></div><p>Abstract type representing a field with data type <code>T</code>, number of dimensions <code>N</code>, location <code>L</code> where the field should be defined on.</p><p>See also: abstract type <a href="/Chmy.jl/dev/lib/modules#Chmy.Fields.ConstantField"><code>ConstantField</code></a></p>',3)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[126]||(s[126]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Fields/abstract_field.jl#L1-L7",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",K,[e("summary",null,[s[128]||(s[128]=e("a",{id:"Chmy.Fields.ConstantField",href:"#Chmy.Fields.ConstantField"},[e("span",{class:"jlbinding"},"Chmy.Fields.ConstantField")],-1)),s[129]||(s[129]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[131]||(s[131]=e("p",null,"Scalar field with a constant value",-1)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[130]||(s[130]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Fields/constant_field.jl#L1",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",q,[e("summary",null,[s[132]||(s[132]=e("a",{id:"Chmy.Fields.Field",href:"#Chmy.Fields.Field"},[e("span",{class:"jlbinding"},"Chmy.Fields.Field")],-1)),s[133]||(s[133]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[135]||(s[135]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Field{T,N,L,H,A} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractField{T,N,L}</span></span></code></pre></div><p>Field represents a discrete scalar field with specified type, number of dimensions, location, and halo size.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[134]||(s[134]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Fields/field.jl#L1-L5",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",W,[e("summary",null,[s[136]||(s[136]=e("a",{id:"Chmy.Fields.Field-Tuple{Architecture, Vararg{Any}}",href:"#Chmy.Fields.Field-Tuple{Architecture, Vararg{Any}}"},[e("span",{class:"jlbinding"},"Chmy.Fields.Field")],-1)),s[137]||(s[137]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[139]||(s[139]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Field</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Architecture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a <code>Field</code> object on the specified architecture.</p><p><strong>Arguments:</strong></p><ul><li><p><code>arch::Architecture</code>: The architecture for which to create the <code>Field</code>.</p></li><li><p><code>args...</code>: Additional positional arguments to pass to the <code>Field</code> constructor.</p></li><li><p><code>kwargs...</code>: Additional keyword arguments to pass to the <code>Field</code> constructor.</p></li></ul>',4)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[138]||(s[138]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Fields/field.jl#L64-L73",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",$,[e("summary",null,[s[140]||(s[140]=e("a",{id:"Chmy.Fields.Field-Union{Tuple{N}, Tuple{KernelAbstractions.Backend, StructuredGrid{N}, Union{NTuple{N, Location}, Location}}, Tuple{KernelAbstractions.Backend, StructuredGrid{N}, Union{NTuple{N, Location}, Location}, Any}} where N",href:"#Chmy.Fields.Field-Union{Tuple{N}, Tuple{KernelAbstractions.Backend, StructuredGrid{N}, Union{NTuple{N, Location}, Location}}, Tuple{KernelAbstractions.Backend, StructuredGrid{N}, Union{NTuple{N, Location}, Location}, Any}} where N"},[e("span",{class:"jlbinding"},"Chmy.Fields.Field")],-1)),s[141]||(s[141]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[143]||(s[143]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Field</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, grid, loc, type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">eltype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid); halo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Constructs a field on a structured grid at the specified location.</p><p><strong>Arguments:</strong></p><ul><li><p><code>backend</code>: The backend to use for memory allocation.</p></li><li><p><code>grid</code>: The structured grid on which the field is constructed.</p></li><li><p><code>loc</code>: The location or locations on the grid where the field is constructed.</p></li><li><p><code>type</code>: The element type of the field. Defaults to the element type of the grid.</p></li><li><p><code>halo</code>: The halo size for the field. Defaults to 1.</p></li></ul>',4)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[142]||(s[142]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Fields/field.jl#L44-L55",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Z,[e("summary",null,[s[144]||(s[144]=e("a",{id:"Chmy.Fields.FunctionField",href:"#Chmy.Fields.FunctionField"},[e("span",{class:"jlbinding"},"Chmy.Fields.FunctionField")],-1)),s[145]||(s[145]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[147]||(s[147]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">FunctionField </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractField</span></span></code></pre></div><p>Continuous or discrete field with values computed at runtime.</p><p><strong>Constructors</strong></p><ul><li><code>FunctionField(func, grid, loc; [discrete], [parameters])</code>: Create a new <code>FunctionField</code> object.</li></ul>',4)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[146]||(s[146]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Fields/function_field.jl#L4-L11",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",J,[e("summary",null,[s[148]||(s[148]=e("a",{id:"Chmy.Fields.FunctionField-Union{Tuple{N}, Tuple{F}, Tuple{F, StructuredGrid{N}, Any}} where {F, N}",href:"#Chmy.Fields.FunctionField-Union{Tuple{N}, Tuple{F}, Tuple{F, StructuredGrid{N}, Any}} where {F, N}"},[e("span",{class:"jlbinding"},"Chmy.Fields.FunctionField")],-1)),s[149]||(s[149]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[151]||(s[151]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FunctionField</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(func</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">F</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, grid</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StructuredGrid{N}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, loc; discrete</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, parameters</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {F,N}</span></span></code></pre></div><p>Create a <code>FunctionField</code> on the given <code>grid</code> using the specified function <code>func</code>.</p><p><strong>Arguments:</strong></p><ul><li><p><code>func::F</code>: The function used to generate the field values.</p></li><li><p><code>grid::StructuredGrid{N}</code>: The structured grid defining the computational domain.</p></li><li><p><code>loc</code>: The nodal location on the grid grid where the function field is defined on.</p></li><li><p><code>discrete=false</code>: A flag indicating whether the field should be discrete. Defaults to <code>false</code>.</p></li><li><p><code>parameters=nothing</code>: Additional parameters to be used by the function. Defaults to <code>nothing</code>.</p></li></ul>',4)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[150]||(s[150]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Fields/function_field.jl#L23-L34",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",H,[e("summary",null,[s[152]||(s[152]=e("a",{id:"Chmy.Fields.OneField",href:"#Chmy.Fields.OneField"},[e("span",{class:"jlbinding"},"Chmy.Fields.OneField")],-1)),s[153]||(s[153]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[155]||(s[155]=e("p",null,"Constant field with values equal to one(T)",-1)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[154]||(s[154]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Fields/constant_field.jl#L16",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Q,[e("summary",null,[s[156]||(s[156]=e("a",{id:"Chmy.Fields.ValueField",href:"#Chmy.Fields.ValueField"},[e("span",{class:"jlbinding"},"Chmy.Fields.ValueField")],-1)),s[157]||(s[157]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[159]||(s[159]=e("p",null,"Field with a constant value",-1)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[158]||(s[158]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Fields/constant_field.jl#L26",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",X,[e("summary",null,[s[160]||(s[160]=e("a",{id:"Chmy.Fields.ZeroField",href:"#Chmy.Fields.ZeroField"},[e("span",{class:"jlbinding"},"Chmy.Fields.ZeroField")],-1)),s[161]||(s[161]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[163]||(s[163]=e("p",null,"Constant field with values equal to zero(T)",-1)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[162]||(s[162]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Fields/constant_field.jl#L6",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Y,[e("summary",null,[s[164]||(s[164]=e("a",{id:"Chmy.Fields.TensorField-Tuple{KernelAbstractions.Backend, StructuredGrid{2}, Vararg{Any}}",href:"#Chmy.Fields.TensorField-Tuple{KernelAbstractions.Backend, StructuredGrid{2}, Vararg{Any}}"},[e("span",{class:"jlbinding"},"Chmy.Fields.TensorField")],-1)),s[165]||(s[165]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[167]||(s[167]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TensorField</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Backend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, grid</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StructuredGrid{2}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a 2D tensor field in the form of a named tuple on the given <code>grid</code> using the specified <code>backend</code>, with components <code>xx</code>, <code>yy</code>, and <code>xy</code> each being a <code>Field</code>.</p><p><strong>Arguments:</strong></p><ul><li><p><code>backend::Backend</code>: The backend to be used for computation.</p></li><li><p><code>grid::StructuredGrid{2}</code>: The 2D structured grid defining the computational domain.</p></li><li><p><code>args...</code>: Additional positional arguments to pass to the <code>Field</code> constructor.</p></li><li><p><code>kwargs...</code>: Additional keyword arguments to pass to the <code>Field</code> constructor.</p></li></ul>',4)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[166]||(s[166]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Fields/field.jl#L171-L181",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",ss,[e("summary",null,[s[168]||(s[168]=e("a",{id:"Chmy.Fields.TensorField-Tuple{KernelAbstractions.Backend, StructuredGrid{3}, Vararg{Any}}",href:"#Chmy.Fields.TensorField-Tuple{KernelAbstractions.Backend, StructuredGrid{3}, Vararg{Any}}"},[e("span",{class:"jlbinding"},"Chmy.Fields.TensorField")],-1)),s[169]||(s[169]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[171]||(s[171]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TensorField</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Backend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, grid</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StructuredGrid{3}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a 3D tensor field in the form of a named tuple on the given <code>grid</code> using the specified <code>backend</code>, with components <code>xx</code>, <code>yy</code>, <code>zz</code>, <code>xy</code>, <code>xz</code>, and <code>yz</code> each being a <code>Field</code>.</p><p><strong>Arguments:</strong></p><ul><li><p><code>backend::Backend</code>: The backend to be used for computation.</p></li><li><p><code>grid::StructuredGrid{3}</code>: The 3D structured grid defining the computational domain.</p></li><li><p><code>args...</code>: Additional positional arguments to pass to the <code>Field</code> constructor.</p></li><li><p><code>kwargs...</code>: Additional keyword arguments to pass to the <code>Field</code> constructor.</p></li></ul>',4)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[170]||(s[170]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Fields/field.jl#L188-L198",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",es,[e("summary",null,[s[172]||(s[172]=e("a",{id:"Chmy.Fields.VectorField-Union{Tuple{N}, Tuple{KernelAbstractions.Backend, StructuredGrid{N}, Vararg{Any}}} where N",href:"#Chmy.Fields.VectorField-Union{Tuple{N}, Tuple{KernelAbstractions.Backend, StructuredGrid{N}, Vararg{Any}}} where N"},[e("span",{class:"jlbinding"},"Chmy.Fields.VectorField")],-1)),s[173]||(s[173]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[175]||(s[175]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">VectorField</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Backend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, grid</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StructuredGrid{N}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {N}</span></span></code></pre></div><p>Create a vector field in the form of a <code>NamedTuple</code> on the given <code>grid</code> using the specified <code>backend</code>. With each component being a <code>Field</code>.</p><p><strong>Arguments:</strong></p><ul><li><p><code>backend::Backend</code>: The backend to be used for computation.</p></li><li><p><code>grid::StructuredGrid{N}</code>: The structured grid defining the computational domain.</p></li><li><p><code>args...</code>: Additional positional arguments to pass to the <code>Field</code> constructor.</p></li><li><p><code>kwargs...</code>: Additional keyword arguments to pass to the <code>Field</code> constructor.</p></li></ul>',4)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[174]||(s[174]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Fields/field.jl#L150-L160",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",is,[e("summary",null,[s[176]||(s[176]=e("a",{id:"Chmy.Fields.interior-Tuple{Field}",href:"#Chmy.Fields.interior-Tuple{Field}"},[e("span",{class:"jlbinding"},"Chmy.Fields.interior")],-1)),s[177]||(s[177]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[179]||(s[179]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">interior</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Field</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; with_halo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Displays the field on the interior of the grid on which it is defined on. One could optionally specify to display the halo regions on the grid with <code>with_halo=true</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[178]||(s[178]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Fields/field.jl#L26-L32",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",ts,[e("summary",null,[s[180]||(s[180]=e("a",{id:"Chmy.Fields.set!-Tuple{Field, AbstractArray}",href:"#Chmy.Fields.set!-Tuple{Field, AbstractArray}"},[e("span",{class:"jlbinding"},"Chmy.Fields.set!")],-1)),s[181]||(s[181]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[183]||(s[183]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Field</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, A</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Set the elements of the <code>Field</code> <code>f</code> using the values from the <code>AbstractArray</code> <code>A</code>.</p><p><strong>Arguments:</strong></p><ul><li><p><code>f::Field</code>: The <code>Field</code> object to be modified.</p></li><li><p><code>A::AbstractArray</code>: The array whose values are to be copied to the <code>Field</code>.</p></li></ul>',4)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[182]||(s[182]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Fields/field.jl#L89-L97",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",as,[e("summary",null,[s[184]||(s[184]=e("a",{id:"Chmy.Fields.set!-Tuple{Field, AbstractField}",href:"#Chmy.Fields.set!-Tuple{Field, AbstractField}"},[e("span",{class:"jlbinding"},"Chmy.Fields.set!")],-1)),s[185]||(s[185]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[187]||(s[187]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Field</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, other</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractField</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Set the elements of the <code>Field</code> <code>f</code> using the values from another <code>AbstractField</code> <code>other</code>.</p><p><strong>Arguments:</strong></p><ul><li><p><code>f::Field</code>: The destination <code>Field</code> object to be modified.</p></li><li><p><code>other::AbstractField</code>: The source <code>AbstractField</code> whose values are to be copied to <code>f</code>.</p></li></ul>',4)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[186]||(s[186]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Fields/field.jl#L100-L108",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",ls,[e("summary",null,[s[188]||(s[188]=e("a",{id:"Chmy.Fields.set!-Tuple{Field, Number}",href:"#Chmy.Fields.set!-Tuple{Field, Number}"},[e("span",{class:"jlbinding"},"Chmy.Fields.set!")],-1)),s[189]||(s[189]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[191]||(s[191]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Field</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, val</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Set all elements of the <code>Field</code> <code>f</code> to the specified numeric value <code>val</code>.</p><p><strong>Arguments:</strong></p><ul><li><p><code>f::Field</code>: The <code>Field</code> object to be modified.</p></li><li><p><code>val::Number</code>: The numeric value to set in the <code>Field</code>.</p></li></ul>',4)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[190]||(s[190]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Fields/field.jl#L78-L86",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[582]||(s[582]=e("h2",{id:"Grid-Operators",tabindex:"-1"},[a("Grid Operators "),e("a",{class:"header-anchor",href:"#Grid-Operators","aria-label":'Permalink to "Grid Operators {#Grid-Operators}"'},"​")],-1)),e("details",rs,[e("summary",null,[s[192]||(s[192]=e("a",{id:"Chmy.GridOperators.AbstractMask",href:"#Chmy.GridOperators.AbstractMask"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.AbstractMask")],-1)),s[193]||(s[193]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[195]||(s[195]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">abstract type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AbstractMask{T,N}</span></span></code></pre></div><p>Abstract type representing the data transformation to be performed on elements in a field of dimension <code>N</code>, where each element is of type<code>T</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[194]||(s[194]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/masked_operators.jl#L1-L6",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",ns,[e("summary",null,[s[196]||(s[196]=e("a",{id:"Chmy.GridOperators.InterpolationRule",href:"#Chmy.GridOperators.InterpolationRule"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.InterpolationRule")],-1)),s[197]||(s[197]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[199]||(s[199]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">abstract type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> InterpolationRule</span></span></code></pre></div><p>A type representing an interpolation rule that specifies how the interpolant <code>f</code> should be reconstructed using a data set on a given grid.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[198]||(s[198]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/interpolation.jl#L3-L8",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",os,[e("summary",null,[s[200]||(s[200]=e("a",{id:"Chmy.GridOperators.divg-Union{Tuple{N}, Tuple{T}, Tuple{names}, Tuple{NamedTuple{names, <:NTuple{N, AbstractField}}, AbstractMask{T, N}, StructuredGrid{N}, Vararg{Integer, N}}} where {names, T, N}",href:"#Chmy.GridOperators.divg-Union{Tuple{N}, Tuple{T}, Tuple{names}, Tuple{NamedTuple{names, <:NTuple{N, AbstractField}}, AbstractMask{T, N}, StructuredGrid{N}, Vararg{Integer, N}}} where {names, T, N}"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.divg")],-1)),s[201]||(s[201]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[203]||(s[203]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">divg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(V, ω, grid, I)</span></span></code></pre></div><p>Compute the divergence of a vector field <code>V</code> on a structured grid <code>grid</code>, using the mask <code>ω</code> to handle masked regions. This operation is performed along all dimensions of the grid.</p><p><strong>Arguments:</strong></p><ul><li><p><code>V</code>: The vector field represented as a named tuple of fields.</p></li><li><p><code>ω</code>: The mask for the grid.</p></li><li><p><code>grid</code>: The structured grid on which the operation is performed.</p></li><li><p><code>I...</code>: The indices specifying the location on the grid.</p></li></ul>',4)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[202]||(s[202]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/masked_field_operators.jl#L39-L50",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",ds,[e("summary",null,[s[204]||(s[204]=e("a",{id:"Chmy.GridOperators.divg-Union{Tuple{N}, Tuple{names}, Tuple{NamedTuple{names, <:NTuple{N, AbstractField}}, StructuredGrid{N}, Vararg{Integer, N}}} where {names, N}",href:"#Chmy.GridOperators.divg-Union{Tuple{N}, Tuple{names}, Tuple{NamedTuple{names, <:NTuple{N, AbstractField}}, StructuredGrid{N}, Vararg{Integer, N}}} where {names, N}"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.divg")],-1)),s[205]||(s[205]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[207]||(s[207]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">divg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(V, grid, I</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute the divergence of a vector field <code>V</code> on a structured grid <code>grid</code>. This operation is performed along all dimensions of the grid.</p><p><strong>Arguments</strong></p><ul><li><p><code>V</code>: The vector field represented as a named tuple of fields.</p></li><li><p><code>grid</code>: The structured grid on which the operation is performed.</p></li><li><p><code>I...</code>: The indices specifying the location on the grid.</p></li></ul>',4)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[206]||(s[206]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/field_operators.jl#L39-L49",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",ps,[e("summary",null,[s[208]||(s[208]=e("a",{id:"Chmy.GridOperators.divg_grad-Union{Tuple{N}, Tuple{AbstractField, AbstractField, StructuredGrid{N}, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.divg_grad-Union{Tuple{N}, Tuple{AbstractField, AbstractField, StructuredGrid{N}, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.divg_grad")],-1)),s[209]||(s[209]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[211]||(s[211]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">divg_grad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(F, K, grid, I</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute the divergence of the gradient of a field <code>F</code> weighted by a coefficient <code>K</code> on a structured grid <code>grid</code>. This operation is performed along all dimensions of the grid.</p><p><strong>Arguments</strong></p><ul><li><p><code>F</code>: The field whose gradient is to be computed.</p></li><li><p><code>K</code>: The weighting field for the gradient.</p></li><li><p><code>grid</code>: The structured grid on which the operation is performed.</p></li><li><p><code>I...</code>: The indices specifying the location on the grid.</p></li></ul>',4)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[210]||(s[210]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/field_operators.jl#L83-L94",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",hs,[e("summary",null,[s[212]||(s[212]=e("a",{id:"Chmy.GridOperators.divg_grad-Union{Tuple{N}, Tuple{T}, Tuple{AbstractField, AbstractField, AbstractMask{T, N}, StructuredGrid{N}, Vararg{Integer, N}}} where {T, N}",href:"#Chmy.GridOperators.divg_grad-Union{Tuple{N}, Tuple{T}, Tuple{AbstractField, AbstractField, AbstractMask{T, N}, StructuredGrid{N}, Vararg{Integer, N}}} where {T, N}"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.divg_grad")],-1)),s[213]||(s[213]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[215]||(s[215]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">divg_grad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(F, K, ω, grid, I</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute the divergence of the diffusion flux of a field <code>F</code> weighted by a coefficient <code>K</code> on a structured grid <code>grid</code>. This operation is performed along all dimensions of the grid.</p><p><strong>Arguments</strong></p><ul><li><p><code>F</code>: The field whose gradient is to be computed.</p></li><li><p><code>K</code>: The weighting field for the gradient.</p></li><li><p><code>ω</code>: The mask for the grid.</p></li><li><p><code>grid</code>: The structured grid on which the operation is performed.</p></li><li><p><code>I...</code>: The indices specifying the location on the grid.</p></li></ul>',4)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[214]||(s[214]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/masked_field_operators.jl#L97-L109",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",cs,[e("summary",null,[s[216]||(s[216]=e("a",{id:"Chmy.GridOperators.hlerp-Union{Tuple{N}, Tuple{Any, Any, Any, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.hlerp-Union{Tuple{N}, Tuple{Any, Any, Any, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.hlerp")],-1)),s[217]||(s[217]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[219]||(s[219]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hlerp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, to, grid, I</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Interpolate a field <code>f</code> to location to using harmonic linear interpolation rule.</p><p><code>rule(t, v0, v1) = 1/(1/v0 + t * (1/v1 - 1/v0))</code></p>',3)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[218]||(s[218]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/interpolation.jl#L96-L102",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",us,[e("summary",null,[s[220]||(s[220]=e("a",{id:"Chmy.GridOperators.itp-Union{Tuple{N}, Tuple{AbstractField, NTuple{N, Location}, InterpolationRule, StructuredGrid{N}, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.itp-Union{Tuple{N}, Tuple{AbstractField, NTuple{N, Location}, InterpolationRule, StructuredGrid{N}, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.itp")],-1)),s[221]||(s[221]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[223]||(s[223]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">itp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, to, r, grid, I</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Interpolates the field <code>f</code> from its current location to the specified location(s) <code>to</code> using the given interpolation rule <code>r</code>. The indices specify the position within the grid at location(s) <code>to</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[222]||(s[222]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/interpolation.jl#L60-L65",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",ks,[e("summary",null,[s[224]||(s[224]=e("a",{id:"Chmy.GridOperators.lapl-Union{Tuple{N}, Tuple{AbstractField, StructuredGrid{N}, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.lapl-Union{Tuple{N}, Tuple{AbstractField, StructuredGrid{N}, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.lapl")],-1)),s[225]||(s[225]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[227]||(s[227]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">lapl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(F, grid, I</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute the Laplacian of a field <code>F</code> on a structured grid <code>grid</code>. This operation is performed along all dimensions of the grid.</p><p><strong>Arguments</strong></p><ul><li><p><code>F</code>: The field whose Laplacian is to be computed.</p></li><li><p><code>grid</code>: The structured grid on which the operation is performed.</p></li><li><p><code>I...</code>: The indices specifying the location on the grid.</p></li></ul>',4)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[226]||(s[226]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/field_operators.jl#L61-L71",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",gs,[e("summary",null,[s[228]||(s[228]=e("a",{id:"Chmy.GridOperators.lapl-Union{Tuple{N}, Tuple{T}, Tuple{AbstractField, AbstractMask{T, N}, StructuredGrid{N}, Vararg{Integer, N}}} where {T, N}",href:"#Chmy.GridOperators.lapl-Union{Tuple{N}, Tuple{T}, Tuple{AbstractField, AbstractMask{T, N}, StructuredGrid{N}, Vararg{Integer, N}}} where {T, N}"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.lapl")],-1)),s[229]||(s[229]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[231]||(s[231]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">lapl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(F, ω, grid, I</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute the Laplacian of a field <code>F</code> on a structured grid <code>grid</code>. This operation is performed along all dimensions of the grid.</p><p><strong>Arguments</strong></p><ul><li><p><code>F</code>: The field whose Laplacian is to be computed.</p></li><li><p><code>ω</code>: The mask for the grid.</p></li><li><p><code>grid</code>: The structured grid on which the operation is performed.</p></li><li><p><code>I...</code>: The indices specifying the location on the grid.</p></li></ul>',4)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[230]||(s[230]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/masked_field_operators.jl#L68-L79",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",ys,[e("summary",null,[s[232]||(s[232]=e("a",{id:"Chmy.GridOperators.leftx-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.leftx-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.leftx")],-1)),s[233]||(s[233]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[235]||(s[235]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">leftx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, ω, I)</span></span></code></pre></div><p>&quot;left side&quot; of a field (<code>[1:end-1]</code>) in x direction, masked with <code>ω</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[234]||(s[234]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/masked_cartesian_field_operators.jl#L12-L16",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",bs,[e("summary",null,[s[236]||(s[236]=e("a",{id:"Chmy.GridOperators.leftx-Union{Tuple{N}, Tuple{AbstractField, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.leftx-Union{Tuple{N}, Tuple{AbstractField, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.leftx")],-1)),s[237]||(s[237]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[239]||(s[239]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">leftx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, I)</span></span></code></pre></div><p>&quot;left side&quot; of a field (<code>[1:end-1]</code>) in x direction.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[238]||(s[238]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/cartesian_field_operators.jl#L12-L16",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",ms,[e("summary",null,[s[240]||(s[240]=e("a",{id:"Chmy.GridOperators.lefty-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.lefty-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.lefty")],-1)),s[241]||(s[241]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[243]||(s[243]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">lefty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, ω, I)</span></span></code></pre></div><p>&quot;left side&quot; of a field (<code>[1:end-1]</code>) in y direction, masked with <code>ω</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[242]||(s[242]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/masked_cartesian_field_operators.jl#L12-L16",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Ts,[e("summary",null,[s[244]||(s[244]=e("a",{id:"Chmy.GridOperators.lefty-Union{Tuple{N}, Tuple{AbstractField, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.lefty-Union{Tuple{N}, Tuple{AbstractField, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.lefty")],-1)),s[245]||(s[245]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[247]||(s[247]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">lefty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, I)</span></span></code></pre></div><p>&quot;left side&quot; of a field (<code>[1:end-1]</code>) in y direction.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[246]||(s[246]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/cartesian_field_operators.jl#L12-L16",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Cs,[e("summary",null,[s[248]||(s[248]=e("a",{id:"Chmy.GridOperators.leftz-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.leftz-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.leftz")],-1)),s[249]||(s[249]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[251]||(s[251]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">leftz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, ω, I)</span></span></code></pre></div><p>&quot;left side&quot; of a field (<code>[1:end-1]</code>) in z direction, masked with <code>ω</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[250]||(s[250]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/masked_cartesian_field_operators.jl#L12-L16",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",fs,[e("summary",null,[s[252]||(s[252]=e("a",{id:"Chmy.GridOperators.leftz-Union{Tuple{N}, Tuple{AbstractField, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.leftz-Union{Tuple{N}, Tuple{AbstractField, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.leftz")],-1)),s[253]||(s[253]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[255]||(s[255]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">leftz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, I)</span></span></code></pre></div><p>&quot;left side&quot; of a field (<code>[1:end-1]</code>) in z direction.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[254]||(s[254]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/cartesian_field_operators.jl#L12-L16",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",_s,[e("summary",null,[s[256]||(s[256]=e("a",{id:"Chmy.GridOperators.lerp-Union{Tuple{N}, Tuple{Any, Any, Any, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.lerp-Union{Tuple{N}, Tuple{Any, Any, Any, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.lerp")],-1)),s[257]||(s[257]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[259]||(s[259]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">lerp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, to, grid, I</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Linearly interpolate values of a field <code>f</code> to location <code>to</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[258]||(s[258]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/interpolation.jl#L89-L93",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",js,[e("summary",null,[s[260]||(s[260]=e("a",{id:"Chmy.GridOperators.rightx-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.rightx-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.rightx")],-1)),s[261]||(s[261]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[263]||(s[263]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rightx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, ω, I)</span></span></code></pre></div><p>&quot;right side&quot; of a field (<code>[2:end]</code>) in x direction, masked with <code>ω</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[262]||(s[262]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/masked_cartesian_field_operators.jl#L21-L25",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Es,[e("summary",null,[s[264]||(s[264]=e("a",{id:"Chmy.GridOperators.rightx-Union{Tuple{N}, Tuple{AbstractField, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.rightx-Union{Tuple{N}, Tuple{AbstractField, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.rightx")],-1)),s[265]||(s[265]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[267]||(s[267]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rightx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, I)</span></span></code></pre></div><p>&quot;right side&quot; of a field (<code>[2:end]</code>) in x direction.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[266]||(s[266]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/cartesian_field_operators.jl#L21-L25",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",As,[e("summary",null,[s[268]||(s[268]=e("a",{id:"Chmy.GridOperators.righty-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.righty-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.righty")],-1)),s[269]||(s[269]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[271]||(s[271]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">righty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, ω, I)</span></span></code></pre></div><p>&quot;right side&quot; of a field (<code>[2:end]</code>) in y direction, masked with <code>ω</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[270]||(s[270]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/masked_cartesian_field_operators.jl#L21-L25",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",vs,[e("summary",null,[s[272]||(s[272]=e("a",{id:"Chmy.GridOperators.righty-Union{Tuple{N}, Tuple{AbstractField, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.righty-Union{Tuple{N}, Tuple{AbstractField, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.righty")],-1)),s[273]||(s[273]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[275]||(s[275]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">righty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, I)</span></span></code></pre></div><p>&quot;right side&quot; of a field (<code>[2:end]</code>) in y direction.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[274]||(s[274]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/cartesian_field_operators.jl#L21-L25",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Fs,[e("summary",null,[s[276]||(s[276]=e("a",{id:"Chmy.GridOperators.rightz-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.rightz-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.rightz")],-1)),s[277]||(s[277]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[279]||(s[279]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rightz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, ω, I)</span></span></code></pre></div><p>&quot;right side&quot; of a field (<code>[2:end]</code>) in z direction, masked with <code>ω</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[278]||(s[278]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/masked_cartesian_field_operators.jl#L21-L25",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Ns,[e("summary",null,[s[280]||(s[280]=e("a",{id:"Chmy.GridOperators.rightz-Union{Tuple{N}, Tuple{AbstractField, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.rightz-Union{Tuple{N}, Tuple{AbstractField, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.rightz")],-1)),s[281]||(s[281]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[283]||(s[283]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rightz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, I)</span></span></code></pre></div><p>&quot;right side&quot; of a field (<code>[2:end]</code>) in z direction.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[282]||(s[282]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/cartesian_field_operators.jl#L21-L25",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",xs,[e("summary",null,[s[284]||(s[284]=e("a",{id:"Chmy.GridOperators.vmag-Union{Tuple{N}, Tuple{names}, Tuple{NamedTuple{names, <:NTuple{N, AbstractField}}, StructuredGrid{N}, Vararg{Integer, N}}} where {names, N}",href:"#Chmy.GridOperators.vmag-Union{Tuple{N}, Tuple{names}, Tuple{NamedTuple{names, <:NTuple{N, AbstractField}}, StructuredGrid{N}, Vararg{Integer, N}}} where {names, N}"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.vmag")],-1)),s[285]||(s[285]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[287]||(s[287]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">vmag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(V, grid, I</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute the magnitude of a vector field <code>V</code> at a given grid location <code>I</code> in a structured grid <code>grid</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>V</code>: A named tuple representing the vector field, where each component is an <code>AbstractField</code>.</p></li><li><p><code>grid</code>: The structured grid on which the vector field is defined.</p></li><li><p><code>I...</code>: The indices specifying the location on the grid.</p></li></ul>',4)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[286]||(s[286]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/field_operators.jl#L106-L115",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Ss,[e("summary",null,[s[288]||(s[288]=e("a",{id:"Chmy.GridOperators.δx-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.δx-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.δx")],-1)),s[289]||(s[289]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[291]||(s[291]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">δx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, ω, I)</span></span></code></pre></div><p>Finite difference in x direction, masked with <code>ω</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[290]||(s[290]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/masked_cartesian_field_operators.jl#L30-L34",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Ds,[e("summary",null,[s[292]||(s[292]=e("a",{id:"Chmy.GridOperators.δx-Union{Tuple{N}, Tuple{AbstractField, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.δx-Union{Tuple{N}, Tuple{AbstractField, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.δx")],-1)),s[293]||(s[293]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[295]||(s[295]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">δx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, I)</span></span></code></pre></div><p>Finite difference in x direction.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[294]||(s[294]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/cartesian_field_operators.jl#L30-L34",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Is,[e("summary",null,[s[296]||(s[296]=e("a",{id:"Chmy.GridOperators.δy-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.δy-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.δy")],-1)),s[297]||(s[297]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[299]||(s[299]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">δy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, ω, I)</span></span></code></pre></div><p>Finite difference in y direction, masked with <code>ω</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[298]||(s[298]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/masked_cartesian_field_operators.jl#L30-L34",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Ps,[e("summary",null,[s[300]||(s[300]=e("a",{id:"Chmy.GridOperators.δy-Union{Tuple{N}, Tuple{AbstractField, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.δy-Union{Tuple{N}, Tuple{AbstractField, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.δy")],-1)),s[301]||(s[301]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[303]||(s[303]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">δy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, I)</span></span></code></pre></div><p>Finite difference in y direction.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[302]||(s[302]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/cartesian_field_operators.jl#L30-L34",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Gs,[e("summary",null,[s[304]||(s[304]=e("a",{id:"Chmy.GridOperators.δz-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.δz-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.δz")],-1)),s[305]||(s[305]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[307]||(s[307]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">δz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, ω, I)</span></span></code></pre></div><p>Finite difference in z direction, masked with <code>ω</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[306]||(s[306]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/masked_cartesian_field_operators.jl#L30-L34",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Vs,[e("summary",null,[s[308]||(s[308]=e("a",{id:"Chmy.GridOperators.δz-Union{Tuple{N}, Tuple{AbstractField, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.δz-Union{Tuple{N}, Tuple{AbstractField, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.δz")],-1)),s[309]||(s[309]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[311]||(s[311]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">δz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, I)</span></span></code></pre></div><p>Finite difference in z direction.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[310]||(s[310]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/cartesian_field_operators.jl#L30-L34",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Os,[e("summary",null,[s[312]||(s[312]=e("a",{id:"Chmy.GridOperators.∂k∂x-Union{Tuple{N}, Tuple{AbstractField, AbstractField, AbstractMask, Any, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.∂k∂x-Union{Tuple{N}, Tuple{AbstractField, AbstractField, AbstractMask, Any, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.∂k∂x")],-1)),s[313]||(s[313]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[315]||(s[315]=e("p",null,"∂k∂x(f, k, ω, grid, I)",-1)),s[316]||(s[316]=e("p",null,[a("Directional divergence of gradient times coefficient "),e("code",null,"k"),a(" in x direction, masked with "),e("code",null,"ω"),a(".")],-1)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[314]||(s[314]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/masked_cartesian_field_operators.jl#L57",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Ls,[e("summary",null,[s[317]||(s[317]=e("a",{id:"Chmy.GridOperators.∂k∂x-Union{Tuple{N}, Tuple{AbstractField, AbstractField, Any, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.∂k∂x-Union{Tuple{N}, Tuple{AbstractField, AbstractField, Any, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.∂k∂x")],-1)),s[318]||(s[318]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[320]||(s[320]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">∂k∂x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, k, grid, I)</span></span></code></pre></div><p>Directional divergence of gradient times coefficient <code>k</code> in x direction.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[319]||(s[319]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/cartesian_field_operators.jl#L57-L61",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Bs,[e("summary",null,[s[321]||(s[321]=e("a",{id:"Chmy.GridOperators.∂k∂y-Union{Tuple{N}, Tuple{AbstractField, AbstractField, AbstractMask, Any, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.∂k∂y-Union{Tuple{N}, Tuple{AbstractField, AbstractField, AbstractMask, Any, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.∂k∂y")],-1)),s[322]||(s[322]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[324]||(s[324]=e("p",null,"∂k∂y(f, k, ω, grid, I)",-1)),s[325]||(s[325]=e("p",null,[a("Directional divergence of gradient times coefficient "),e("code",null,"k"),a(" in y direction, masked with "),e("code",null,"ω"),a(".")],-1)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[323]||(s[323]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/masked_cartesian_field_operators.jl#L57",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",ws,[e("summary",null,[s[326]||(s[326]=e("a",{id:"Chmy.GridOperators.∂k∂y-Union{Tuple{N}, Tuple{AbstractField, AbstractField, Any, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.∂k∂y-Union{Tuple{N}, Tuple{AbstractField, AbstractField, Any, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.∂k∂y")],-1)),s[327]||(s[327]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[329]||(s[329]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">∂k∂y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, k, grid, I)</span></span></code></pre></div><p>Directional divergence of gradient times coefficient <code>k</code> in y direction.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[328]||(s[328]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/cartesian_field_operators.jl#L57-L61",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Ms,[e("summary",null,[s[330]||(s[330]=e("a",{id:"Chmy.GridOperators.∂k∂z-Union{Tuple{N}, Tuple{AbstractField, AbstractField, AbstractMask, Any, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.∂k∂z-Union{Tuple{N}, Tuple{AbstractField, AbstractField, AbstractMask, Any, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.∂k∂z")],-1)),s[331]||(s[331]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[333]||(s[333]=e("p",null,"∂k∂z(f, k, ω, grid, I)",-1)),s[334]||(s[334]=e("p",null,[a("Directional divergence of gradient times coefficient "),e("code",null,"k"),a(" in z direction, masked with "),e("code",null,"ω"),a(".")],-1)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[332]||(s[332]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/masked_cartesian_field_operators.jl#L57",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Us,[e("summary",null,[s[335]||(s[335]=e("a",{id:"Chmy.GridOperators.∂k∂z-Union{Tuple{N}, Tuple{AbstractField, AbstractField, Any, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.∂k∂z-Union{Tuple{N}, Tuple{AbstractField, AbstractField, Any, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.∂k∂z")],-1)),s[336]||(s[336]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[338]||(s[338]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">∂k∂z</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, k, grid, I)</span></span></code></pre></div><p>Directional divergence of gradient times coefficient <code>k</code> in z direction.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[337]||(s[337]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/cartesian_field_operators.jl#L57-L61",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Rs,[e("summary",null,[s[339]||(s[339]=e("a",{id:"Chmy.GridOperators.∂x-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Any, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.∂x-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Any, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.∂x")],-1)),s[340]||(s[340]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[342]||(s[342]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">∂x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, ω, grid, I)</span></span></code></pre></div><p>Directional partial derivative in x direction, masked with <code>ω</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[341]||(s[341]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/masked_cartesian_field_operators.jl#L39-L43",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",zs,[e("summary",null,[s[343]||(s[343]=e("a",{id:"Chmy.GridOperators.∂x-Union{Tuple{N}, Tuple{AbstractField, Any, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.∂x-Union{Tuple{N}, Tuple{AbstractField, Any, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.∂x")],-1)),s[344]||(s[344]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[346]||(s[346]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">∂x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, grid, I)</span></span></code></pre></div><p>Directional partial derivative in x direction.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[345]||(s[345]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/cartesian_field_operators.jl#L39-L43",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Ks,[e("summary",null,[s[347]||(s[347]=e("a",{id:"Chmy.GridOperators.∂y-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Any, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.∂y-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Any, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.∂y")],-1)),s[348]||(s[348]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[350]||(s[350]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">∂y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, ω, grid, I)</span></span></code></pre></div><p>Directional partial derivative in y direction, masked with <code>ω</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[349]||(s[349]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/masked_cartesian_field_operators.jl#L39-L43",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",qs,[e("summary",null,[s[351]||(s[351]=e("a",{id:"Chmy.GridOperators.∂y-Union{Tuple{N}, Tuple{AbstractField, Any, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.∂y-Union{Tuple{N}, Tuple{AbstractField, Any, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.∂y")],-1)),s[352]||(s[352]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[354]||(s[354]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">∂y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, grid, I)</span></span></code></pre></div><p>Directional partial derivative in y direction.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[353]||(s[353]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/cartesian_field_operators.jl#L39-L43",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Ws,[e("summary",null,[s[355]||(s[355]=e("a",{id:"Chmy.GridOperators.∂z-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Any, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.∂z-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Any, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.∂z")],-1)),s[356]||(s[356]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[358]||(s[358]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">∂z</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, ω, grid, I)</span></span></code></pre></div><p>Directional partial derivative in z direction, masked with <code>ω</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[357]||(s[357]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/masked_cartesian_field_operators.jl#L39-L43",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",$s,[e("summary",null,[s[359]||(s[359]=e("a",{id:"Chmy.GridOperators.∂z-Union{Tuple{N}, Tuple{AbstractField, Any, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.∂z-Union{Tuple{N}, Tuple{AbstractField, Any, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.∂z")],-1)),s[360]||(s[360]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[362]||(s[362]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">∂z</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, grid, I)</span></span></code></pre></div><p>Directional partial derivative in z direction.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[361]||(s[361]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/cartesian_field_operators.jl#L39-L43",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Zs,[e("summary",null,[s[363]||(s[363]=e("a",{id:"Chmy.GridOperators.∂²x-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Any, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.∂²x-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Any, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.∂²x")],-1)),s[364]||(s[364]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[366]||(s[366]=e("p",null,"∂²x(f, ω, grid, I)",-1)),s[367]||(s[367]=e("p",null,[a("Directional partial second derivative in x direction, masked with "),e("code",null,"ω"),a(".")],-1)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[365]||(s[365]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/masked_cartesian_field_operators.jl#L48",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Js,[e("summary",null,[s[368]||(s[368]=e("a",{id:"Chmy.GridOperators.∂²x-Union{Tuple{N}, Tuple{AbstractField, Any, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.∂²x-Union{Tuple{N}, Tuple{AbstractField, Any, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.∂²x")],-1)),s[369]||(s[369]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[371]||(s[371]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">∂²x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, grid, I)</span></span></code></pre></div><p>Directional partial second derivative in x direction.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[370]||(s[370]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/cartesian_field_operators.jl#L48-L52",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Hs,[e("summary",null,[s[372]||(s[372]=e("a",{id:"Chmy.GridOperators.∂²y-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Any, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.∂²y-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Any, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.∂²y")],-1)),s[373]||(s[373]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[375]||(s[375]=e("p",null,"∂²y(f, ω, grid, I)",-1)),s[376]||(s[376]=e("p",null,[a("Directional partial second derivative in y direction, masked with "),e("code",null,"ω"),a(".")],-1)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[374]||(s[374]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/masked_cartesian_field_operators.jl#L48",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Qs,[e("summary",null,[s[377]||(s[377]=e("a",{id:"Chmy.GridOperators.∂²y-Union{Tuple{N}, Tuple{AbstractField, Any, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.∂²y-Union{Tuple{N}, Tuple{AbstractField, Any, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.∂²y")],-1)),s[378]||(s[378]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[380]||(s[380]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">∂²y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, grid, I)</span></span></code></pre></div><p>Directional partial second derivative in y direction.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[379]||(s[379]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/cartesian_field_operators.jl#L48-L52",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Xs,[e("summary",null,[s[381]||(s[381]=e("a",{id:"Chmy.GridOperators.∂²z-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Any, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.∂²z-Union{Tuple{N}, Tuple{AbstractField, AbstractMask, Any, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.∂²z")],-1)),s[382]||(s[382]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[384]||(s[384]=e("p",null,"∂²z(f, ω, grid, I)",-1)),s[385]||(s[385]=e("p",null,[a("Directional partial second derivative in z direction, masked with "),e("code",null,"ω"),a(".")],-1)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[383]||(s[383]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/masked_cartesian_field_operators.jl#L48",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Ys,[e("summary",null,[s[386]||(s[386]=e("a",{id:"Chmy.GridOperators.∂²z-Union{Tuple{N}, Tuple{AbstractField, Any, Vararg{Integer, N}}} where N",href:"#Chmy.GridOperators.∂²z-Union{Tuple{N}, Tuple{AbstractField, Any, Vararg{Integer, N}}} where N"},[e("span",{class:"jlbinding"},"Chmy.GridOperators.∂²z")],-1)),s[387]||(s[387]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[389]||(s[389]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">∂²z</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, grid, I)</span></span></code></pre></div><p>Directional partial second derivative in z direction.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[388]||(s[388]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/GridOperators/cartesian_field_operators.jl#L48-L52",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[583]||(s[583]=e("h2",{id:"Boundary-Conditions",tabindex:"-1"},[a("Boundary Conditions "),e("a",{class:"header-anchor",href:"#Boundary-Conditions","aria-label":'Permalink to "Boundary Conditions {#Boundary-Conditions}"'},"​")],-1)),e("details",se,[e("summary",null,[s[390]||(s[390]=e("a",{id:"Chmy.BoundaryConditions.AbstractBatch",href:"#Chmy.BoundaryConditions.AbstractBatch"},[e("span",{class:"jlbinding"},"Chmy.BoundaryConditions.AbstractBatch")],-1)),s[391]||(s[391]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[393]||(s[393]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractBatch</span></span></code></pre></div><p>Abstract type representing a batch of boundary conditions.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[392]||(s[392]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/BoundaryConditions/batch.jl#L1-L5",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",ee,[e("summary",null,[s[394]||(s[394]=e("a",{id:"Chmy.BoundaryConditions.BoundaryFunction",href:"#Chmy.BoundaryConditions.BoundaryFunction"},[e("span",{class:"jlbinding"},"Chmy.BoundaryConditions.BoundaryFunction")],-1)),s[395]||(s[395]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[397]||(s[397]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">abstract type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> BoundaryFunction{F}</span></span></code></pre></div><p>Abstract type for boundary condition functions with function type <code>F</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[396]||(s[396]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/BoundaryConditions/boundary_function.jl#L1-L5",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",ie,[e("summary",null,[s[398]||(s[398]=e("a",{id:"Chmy.BoundaryConditions.BoundaryFunction-Tuple{Function}",href:"#Chmy.BoundaryConditions.BoundaryFunction-Tuple{Function}"},[e("span",{class:"jlbinding"},"Chmy.BoundaryConditions.BoundaryFunction")],-1)),s[399]||(s[399]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[401]||(s[401]=r(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BoundaryFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fun; discrete</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, parameters</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, reduce_dims</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Creates a &quot;boundary function&quot; object that can be use to define boundary conditions on fields.</p><p><strong>Arguments</strong></p><ul><li><p><code>fun</code>: The function defining the boundary condition.</p></li><li><p><code>discrete=false</code>: If <code>true</code>, the boundary function is discrete and has the signature <code>f(grid, loc, dim, inds...)</code>.</p></li><li><p><code>parameters=nothing</code>: Optional parameters to be passed to the boundary function.</p></li><li><p><code>reduce_dims=true</code>: If <code>true</code>, the boundary function reduces the number of dimensions it operates on. If <code>false</code>, the function accepts the same number of coordinates as the number of indices.</p></li></ul><p><strong>Usage</strong></p><p>The example below shows how to use the boundary function to initialise a parabolic profile at the boundary of a 2D grid.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Chmy</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Arch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CPU</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">grid </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UniformGrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arch; origin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), extent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), dims</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Field</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arch, grid, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Center</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">xbc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> BoundaryFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((x, ly) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ly </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x); parameters</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bc!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arch, grid, f </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dirichlet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xbc), y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Neumann</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()))</span></span></code></pre></div>`,7)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[400]||(s[400]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/BoundaryConditions/boundary_function.jl#L46-L71",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",te,[e("summary",null,[s[402]||(s[402]=e("a",{id:"Chmy.BoundaryConditions.Dirichlet",href:"#Chmy.BoundaryConditions.Dirichlet"},[e("span",{class:"jlbinding"},"Chmy.BoundaryConditions.Dirichlet")],-1)),s[403]||(s[403]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[405]||(s[405]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dirichlet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a <code>Dirichlet</code> object representing the Dirichlet boundary condition with the specified value.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[404]||(s[404]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/BoundaryConditions/first_order_boundary_condition.jl#L17-L21",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",ae,[e("summary",null,[s[406]||(s[406]=e("a",{id:"Chmy.BoundaryConditions.EmptyBatch",href:"#Chmy.BoundaryConditions.EmptyBatch"},[e("span",{class:"jlbinding"},"Chmy.BoundaryConditions.EmptyBatch")],-1)),s[407]||(s[407]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[409]||(s[409]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EmptyBatch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractBatch</span></span></code></pre></div><p>EmptyBatch represents no boundary conditions.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[408]||(s[408]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/BoundaryConditions/batch.jl#L31-L35",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",le,[e("summary",null,[s[410]||(s[410]=e("a",{id:"Chmy.BoundaryConditions.ExchangeBatch",href:"#Chmy.BoundaryConditions.ExchangeBatch"},[e("span",{class:"jlbinding"},"Chmy.BoundaryConditions.ExchangeBatch")],-1)),s[411]||(s[411]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[413]||(s[413]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ExchangeBatch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractBatch</span></span></code></pre></div><p>ExchangeBatch represents a batch used for MPI communication.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[412]||(s[412]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/BoundaryConditions/batch.jl#L56-L60",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",re,[e("summary",null,[s[414]||(s[414]=e("a",{id:"Chmy.BoundaryConditions.FieldBatch",href:"#Chmy.BoundaryConditions.FieldBatch"},[e("span",{class:"jlbinding"},"Chmy.BoundaryConditions.FieldBatch")],-1)),s[415]||(s[415]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[417]||(s[417]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">FieldBatch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractBatch</span></span></code></pre></div><p>FieldBatch is a batch of boundary conditions, where each field has one boundary condition.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[416]||(s[416]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/BoundaryConditions/batch.jl#L40-L44",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",ne,[e("summary",null,[s[418]||(s[418]=e("a",{id:"Chmy.BoundaryConditions.FieldBoundaryCondition",href:"#Chmy.BoundaryConditions.FieldBoundaryCondition"},[e("span",{class:"jlbinding"},"Chmy.BoundaryConditions.FieldBoundaryCondition")],-1)),s[419]||(s[419]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[421]||(s[421]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">FieldBoundaryCondition</span></span></code></pre></div><p>Abstract supertype for all boundary conditions that are specified per-field.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[420]||(s[420]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/BoundaryConditions/BoundaryConditions.jl#L22-L26",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",oe,[e("summary",null,[s[422]||(s[422]=e("a",{id:"Chmy.BoundaryConditions.FirstOrderBC",href:"#Chmy.BoundaryConditions.FirstOrderBC"},[e("span",{class:"jlbinding"},"Chmy.BoundaryConditions.FirstOrderBC")],-1)),s[423]||(s[423]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[425]||(s[425]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> FirstOrderBC{T,Kind} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> FieldBoundaryCondition</span></span></code></pre></div><p>A struct representing a boundary condition of first-order accuracy.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[424]||(s[424]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/BoundaryConditions/first_order_boundary_condition.jl#L4-L8",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",de,[e("summary",null,[s[426]||(s[426]=e("a",{id:"Chmy.BoundaryConditions.Neumann",href:"#Chmy.BoundaryConditions.Neumann"},[e("span",{class:"jlbinding"},"Chmy.BoundaryConditions.Neumann")],-1)),s[427]||(s[427]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[429]||(s[429]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Neumann</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a <code>Neumann</code> object representing the Neumann boundary condition with the specified value.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[428]||(s[428]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/BoundaryConditions/first_order_boundary_condition.jl#L24-L28",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",pe,[e("summary",null,[s[430]||(s[430]=e("a",{id:"Chmy.BoundaryConditions.bc!-Union{Tuple{N}, Tuple{Architecture, StructuredGrid{N}, NTuple{N, Tuple{AbstractBatch, AbstractBatch}}}} where N",href:"#Chmy.BoundaryConditions.bc!-Union{Tuple{N}, Tuple{Architecture, StructuredGrid{N}, NTuple{N, Tuple{AbstractBatch, AbstractBatch}}}} where N"},[e("span",{class:"jlbinding"},"Chmy.BoundaryConditions.bc!")],-1)),s[431]||(s[431]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[433]||(s[433]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bc!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Architecture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, grid</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StructuredGrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, batch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BatchSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Apply boundary conditions using a batch set <code>batch</code> containing an <code>AbstractBatch</code> per dimension per side of <code>grid</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>arch</code>: The architecture.</p></li><li><p><code>grid</code>: The grid.</p></li><li><p><code>batch:</code>: The batch set to apply boundary conditions to.</p></li></ul>',4)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[432]||(s[432]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/BoundaryConditions/batch.jl#L10-L19",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[584]||(s[584]=e("h2",{id:"Kernel-launcher",tabindex:"-1"},[a("Kernel launcher "),e("a",{class:"header-anchor",href:"#Kernel-launcher","aria-label":'Permalink to "Kernel launcher {#Kernel-launcher}"'},"​")],-1)),e("details",he,[e("summary",null,[s[434]||(s[434]=e("a",{id:"Chmy.KernelLaunch.Launcher",href:"#Chmy.KernelLaunch.Launcher"},[e("span",{class:"jlbinding"},"Chmy.KernelLaunch.Launcher")],-1)),s[435]||(s[435]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[437]||(s[437]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Launcher{Worksize,OuterWidth,Workers}</span></span></code></pre></div><p>A struct representing a launcher for asynchronous kernel execution.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[436]||(s[436]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/KernelLaunch.jl#L16-L20",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",ce,[e("summary",null,[s[438]||(s[438]=e("a",{id:"Chmy.KernelLaunch.Launcher-Tuple{Any, Any}",href:"#Chmy.KernelLaunch.Launcher-Tuple{Any, Any}"},[e("span",{class:"jlbinding"},"Chmy.KernelLaunch.Launcher")],-1)),s[439]||(s[439]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[441]||(s[441]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Launcher</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arch, grid; outer_width</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Constructs a <code>Launcher</code> object configured based on the input parameters.</p><p><strong>Arguments:</strong></p><ul><li><p><code>arch</code>: The associated architecture.</p></li><li><p><code>grid</code>: The grid defining the computational domain.</p></li><li><p><code>outer_width</code>: Optional parameter specifying outer width.</p></li></ul><div class="warning custom-block"><p class="custom-block-title">Warning</p><p>worksize for the last dimension N takes into account only last outer width W[N], N-1 uses W[N] and W[N-1], N-2 uses W[N], W[N-1], and W[N-2].</p></div>',5)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[440]||(s[440]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/KernelLaunch.jl#L25-L39",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",ue,[e("summary",null,[s[442]||(s[442]=e("a",{id:"Chmy.KernelLaunch.Launcher-Union{Tuple{Args}, Tuple{F}, Tuple{Architecture, Any, Pair{F, Args}}} where {F, Args}",href:"#Chmy.KernelLaunch.Launcher-Union{Tuple{Args}, Tuple{F}, Tuple{Architecture, Any, Pair{F, Args}}} where {F, Args}"},[e("span",{class:"jlbinding"},"Chmy.KernelLaunch.Launcher")],-1)),s[443]||(s[443]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[445]||(s[445]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(launcher</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Launcher</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(arch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Architecture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, grid, kernel_and_args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Pair{F,Args}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; bc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {F,Args}</span></span></code></pre></div><p>Launches a computational kernel using the specified <code>arch</code>, <code>grid</code>, <code>kernel_and_args</code>, and optional boundary conditions (<code>bc</code>).</p><p><strong>Arguments:</strong></p><ul><li><p><code>arch::Architecture</code>: The architecture on which to execute the computation.</p></li><li><p><code>grid</code>: The grid defining the computational domain.</p></li><li><p><code>kernel_and_args::Pair{F,Args}</code>: A pair consisting of the computational kernel <code>F</code> and its arguments <code>Args</code>.</p></li><li><p><code>bc=nothing</code>: Optional boundary conditions for the computation.</p></li></ul><div class="warning custom-block"><p class="custom-block-title">Warning</p><ul><li><p><code>arch</code> should be compatible with the <code>Launcher</code>&#39;s architecture.</p></li><li><p>If <code>bc</code> is <code>nothing</code>, the kernel is launched without boundary conditions.</p></li><li><p>The function waits for the computation to complete before returning.</p></li></ul></div>',5)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[444]||(s[444]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/KernelLaunch.jl#L89-L104",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[585]||(s[585]=e("h2",{id:"distributed",tabindex:"-1"},[a("Distributed "),e("a",{class:"header-anchor",href:"#distributed","aria-label":'Permalink to "Distributed"'},"​")],-1)),e("details",ke,[e("summary",null,[s[446]||(s[446]=e("a",{id:"Chmy.Distributed.CartesianTopology",href:"#Chmy.Distributed.CartesianTopology"},[e("span",{class:"jlbinding"},"Chmy.Distributed.CartesianTopology")],-1)),s[447]||(s[447]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[449]||(s[449]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CartesianTopology</span></span></code></pre></div><p>Represents N-dimensional Cartesian topology of distributed processes.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[448]||(s[448]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/topology.jl#L1-L5",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",ge,[e("summary",null,[s[450]||(s[450]=e("a",{id:"Chmy.Distributed.CartesianTopology-Union{Tuple{N}, Tuple{MPI.Comm, NTuple{N, Int64}}} where N",href:"#Chmy.Distributed.CartesianTopology-Union{Tuple{N}, Tuple{MPI.Comm, NTuple{N, Int64}}} where N"},[e("span",{class:"jlbinding"},"Chmy.Distributed.CartesianTopology")],-1)),s[451]||(s[451]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[453]||(s[453]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CartesianTopology</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(comm, dims)</span></span></code></pre></div><p>Create an N-dimensional Cartesian topology using base MPI communicator <code>comm</code> with dimensions <code>dims</code>. If all entries in <code>dims</code> are not equal to <code>0</code>, the product of <code>dims</code> should be equal to the total number of MPI processes <code>MPI.Comm_size(comm)</code>. If any (or all) entries of <code>dims</code> are <code>0</code>, the dimensions in the corresponding spatial directions will be picked automatically.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[452]||(s[452]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/topology.jl#L19-L25",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",ye,[e("summary",null,[s[454]||(s[454]=e("a",{id:"Chmy.Distributed.DistributedArchitecture",href:"#Chmy.Distributed.DistributedArchitecture"},[e("span",{class:"jlbinding"},"Chmy.Distributed.DistributedArchitecture")],-1)),s[455]||(s[455]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[457]||(s[457]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DistributedArchitecture </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Architecture</span></span></code></pre></div><p>A struct representing a distributed architecture.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[456]||(s[456]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/distributed_architecture.jl#L1-L5",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",be,[e("summary",null,[s[458]||(s[458]=e("a",{id:"Chmy.Distributed.StackAllocator",href:"#Chmy.Distributed.StackAllocator"},[e("span",{class:"jlbinding"},"Chmy.Distributed.StackAllocator")],-1)),s[459]||(s[459]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[461]||(s[461]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mutable struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> StackAllocator</span></span></code></pre></div><p>Simple stack (a.k.a. bump/arena) allocator. Maintains an internal buffer that grows dynamically if the requested allocation exceeds current buffer size.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[460]||(s[460]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/stack_allocator.jl#L1-L6",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",me,[e("summary",null,[s[462]||(s[462]=e("a",{id:"Chmy.Distributed.StackAllocator-Tuple{KernelAbstractions.Backend}",href:"#Chmy.Distributed.StackAllocator-Tuple{KernelAbstractions.Backend}"},[e("span",{class:"jlbinding"},"Chmy.Distributed.StackAllocator")],-1)),s[463]||(s[463]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[465]||(s[465]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StackAllocator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Backend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a stack allocator using the specified backend to store allocations.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[464]||(s[464]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/stack_allocator.jl#L13-L17",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Te,[e("summary",null,[s[466]||(s[466]=e("a",{id:"Base.resize!-Tuple{Chmy.Distributed.StackAllocator, Integer}",href:"#Base.resize!-Tuple{Chmy.Distributed.StackAllocator, Integer}"},[e("span",{class:"jlbinding"},"Base.resize!")],-1)),s[467]||(s[467]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[469]||(s[469]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">resize!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sa</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StackAllocator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sz</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Resize the StackAllocator&#39;s buffer to capacity of <code>sz</code> bytes. This method will throw an error if any arrays were already allocated using this allocator.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[468]||(s[468]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/stack_allocator.jl#L34-L39",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Ce,[e("summary",null,[s[470]||(s[470]=e("a",{id:"Chmy.Architectures.Arch-Tuple{KernelAbstractions.Backend, MPI.Comm, Any}",href:"#Chmy.Architectures.Arch-Tuple{KernelAbstractions.Backend, MPI.Comm, Any}"},[e("span",{class:"jlbinding"},"Chmy.Architectures.Arch")],-1)),s[471]||(s[471]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[473]||(s[473]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Architectures</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Arch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Backend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, comm</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MPI.Comm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dims; device_id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gpu_aware</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a distributed Architecture using backend <code>backend</code> and <code>comm</code>. For GPU backends, device will be selected automatically based on a process id within a node, unless specified by <code>device_id</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>backend::Backend</code>: The backend to use for the architecture.</p></li><li><p><code>comm::MPI.Comm</code>: The MPI communicator to use for the architecture.</p></li><li><p><code>dims</code>: The dimensions of the architecture.</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>device_id</code>: The ID of the device to use. If not provided, the shared rank of the topology plus one is used.</p></li><li><p><code>gpu_aware</code>: Whether the MPI implementation is GPU-aware. If not provided, defaults to <code>true</code>. Only applies to compatible backends.</p></li></ul>',6)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[472]||(s[472]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/distributed_architecture.jl#L12-L26",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",fe,[e("summary",null,[s[474]||(s[474]=e("a",{id:"Chmy.Architectures.activate!-Tuple{DistributedArchitecture}",href:"#Chmy.Architectures.activate!-Tuple{DistributedArchitecture}"},[e("span",{class:"jlbinding"},"Chmy.Architectures.activate!")],-1)),s[475]||(s[475]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[477]||(s[477]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">activate!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DistributedArchitecture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Activate the given DistributedArchitecture by delegating to the child architecture, and pass through any keyword arguments. For example, the priority can be set with accepted values being <code>:normal</code>, <code>:low</code>, and <code>:high</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[476]||(s[476]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/distributed_architecture.jl#L65-L71",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",_e,[e("summary",null,[s[478]||(s[478]=e("a",{id:"Chmy.Architectures.get_device-Tuple{DistributedArchitecture}",href:"#Chmy.Architectures.get_device-Tuple{DistributedArchitecture}"},[e("span",{class:"jlbinding"},"Chmy.Architectures.get_device")],-1)),s[479]||(s[479]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[481]||(s[481]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_device</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DistributedArchitecture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the device associated with a DistributedArchitecture by delegating to the child architecture.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[480]||(s[480]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/distributed_architecture.jl#L58-L62",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",je,[e("summary",null,[s[482]||(s[482]=e("a",{id:"Chmy.BoundaryConditions.bc!-Tuple{Side, Dim, DistributedArchitecture, StructuredGrid, ExchangeBatch}",href:"#Chmy.BoundaryConditions.bc!-Tuple{Side, Dim, DistributedArchitecture, StructuredGrid, ExchangeBatch}"},[e("span",{class:"jlbinding"},"Chmy.BoundaryConditions.bc!")],-1)),s[483]||(s[483]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[485]||(s[485]=r(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BoundaryConditions</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bc!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(side</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Side</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                            arch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DistributedArchitecture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                            grid</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StructuredGrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                            batch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ExchangeBatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Apply boundary conditions on a distributed grid with halo exchange performed internally.</p><p><strong>Arguments</strong></p><ul><li><p><code>side</code>: The side of the grid where the halo exchange is performed.</p></li><li><p><code>dim</code>: The dimension along which the halo exchange is performed.</p></li><li><p><code>arch</code>: The distributed architecture used for communication.</p></li><li><p><code>grid</code>: The structured grid on which the halo exchange is performed.</p></li><li><p><code>batch</code>: The batch set to apply boundary conditions to.</p></li></ul>`,4)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[484]||(s[484]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/exchange_halo.jl#L86-L100",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Ee,[e("summary",null,[s[486]||(s[486]=e("a",{id:"Chmy.Distributed.allocate",href:"#Chmy.Distributed.allocate"},[e("span",{class:"jlbinding"},"Chmy.Distributed.allocate")],-1)),s[487]||(s[487]=a()),t(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[489]||(s[489]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">allocate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sa</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StackAllocator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dims, [align</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(T)])</span></span></code></pre></div><p>Allocate a buffer of type <code>T</code> with dimensions <code>dims</code> using a stack allocator. The <code>align</code> parameter specifies the alignment of the buffer elements.</p><p><strong>Arguments</strong></p><ul><li><p><code>sa::StackAllocator</code>: The stack allocator object.</p></li><li><p><code>T::DataType</code>: The data type of the requested allocation.</p></li><li><p><code>dims</code>: The dimensions of the requested allocation.</p></li><li><p><code>align::Integer</code>: The alignment of the allocated buffer in bytes.</p></li></ul><div class="warning custom-block"><p class="custom-block-title">Warning</p><p>Arrays allocated with StackAllocator are not managed by Julia runtime. User is responsible for ensuring correct lifetimes, i.e., that the reference to allocator outlives all arrays allocated using this allocator.</p></div>',5)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[488]||(s[488]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/stack_allocator.jl#L57-L74",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Ae,[e("summary",null,[s[490]||(s[490]=e("a",{id:"Chmy.Distributed.cart_comm-Tuple{CartesianTopology}",href:"#Chmy.Distributed.cart_comm-Tuple{CartesianTopology}"},[e("span",{class:"jlbinding"},"Chmy.Distributed.cart_comm")],-1)),s[491]||(s[491]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[493]||(s[493]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cart_comm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(topo)</span></span></code></pre></div><p>MPI Cartesian communicator for the topology.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[492]||(s[492]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/topology.jl#L64-L68",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",ve,[e("summary",null,[s[494]||(s[494]=e("a",{id:"Chmy.Distributed.cart_coords-Tuple{CartesianTopology}",href:"#Chmy.Distributed.cart_coords-Tuple{CartesianTopology}"},[e("span",{class:"jlbinding"},"Chmy.Distributed.cart_coords")],-1)),s[495]||(s[495]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[497]||(s[497]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cart_coords</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(topo)</span></span></code></pre></div><p>Coordinates of a current process within a Cartesian topology.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[496]||(s[496]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/topology.jl#L85-L89",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Fe,[e("summary",null,[s[498]||(s[498]=e("a",{id:"Chmy.Distributed.dims-Tuple{CartesianTopology}",href:"#Chmy.Distributed.dims-Tuple{CartesianTopology}"},[e("span",{class:"jlbinding"},"Chmy.Distributed.dims")],-1)),s[499]||(s[499]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[501]||(s[501]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">dims</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(topo)</span></span></code></pre></div><p>Dimensions of the topology as NTuple.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[500]||(s[500]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/topology.jl#L78-L82",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Ne,[e("summary",null,[s[502]||(s[502]=e("a",{id:"Chmy.Distributed.exchange_halo!-Union{Tuple{K}, Tuple{D}, Tuple{S}, Tuple{Side{S}, Dim{D}, DistributedArchitecture, StructuredGrid, Vararg{Field, K}}} where {S, D, K}",href:"#Chmy.Distributed.exchange_halo!-Union{Tuple{K}, Tuple{D}, Tuple{S}, Tuple{Side{S}, Dim{D}, DistributedArchitecture, StructuredGrid, Vararg{Field, K}}} where {S, D, K}"},[e("span",{class:"jlbinding"},"Chmy.Distributed.exchange_halo!")],-1)),s[503]||(s[503]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[505]||(s[505]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exchange_halo!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(side</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Side</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, arch, grid, fields</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Perform halo exchange communication between neighboring processes in a distributed architecture.</p><p><strong>Arguments</strong></p><ul><li><p><code>side</code>: The side of the grid where the halo exchange is performed.</p></li><li><p><code>dim</code>: The dimension along which the halo exchange is performed.</p></li><li><p><code>arch</code>: The distributed architecture used for communication.</p></li><li><p><code>grid</code>: The structured grid on which the halo exchange is performed.</p></li><li><p><code>fields...</code>: The fields to be exchanged.</p></li></ul>',4)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[504]||(s[504]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/exchange_halo.jl#L1-L12",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",xe,[e("summary",null,[s[506]||(s[506]=e("a",{id:"Chmy.Distributed.exchange_halo!-Union{Tuple{N}, Tuple{DistributedArchitecture, StructuredGrid{N}, Vararg{Field}}} where N",href:"#Chmy.Distributed.exchange_halo!-Union{Tuple{N}, Tuple{DistributedArchitecture, StructuredGrid{N}, Vararg{Field}}} where N"},[e("span",{class:"jlbinding"},"Chmy.Distributed.exchange_halo!")],-1)),s[507]||(s[507]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[509]||(s[509]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exchange_halo!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arch, grid, fields</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Perform halo exchange for the given architecture, grid, and fields.</p><p><strong>Arguments</strong></p><ul><li><p><code>arch</code>: The distributed architecture to perform halo exchange on.</p></li><li><p><code>grid</code>: The structured grid on which halo exchange is performed.</p></li><li><p><code>fields</code>: The fields on which halo exchange is performed.</p></li></ul>',4)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[508]||(s[508]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/exchange_halo.jl#L63-L72",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Se,[e("summary",null,[s[510]||(s[510]=e("a",{id:"Chmy.Distributed.gather!-Tuple{DistributedArchitecture, Any, Field}",href:"#Chmy.Distributed.gather!-Tuple{DistributedArchitecture, Any, Field}"},[e("span",{class:"jlbinding"},"Chmy.Distributed.gather!")],-1)),s[511]||(s[511]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[513]||(s[513]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">gather!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arch, dst, src</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Field</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Gather the interior of a field <code>src</code> into a global array <code>dst</code> on the CPU.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[512]||(s[512]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/gather.jl#L35-L39",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",De,[e("summary",null,[s[514]||(s[514]=e("a",{id:"Chmy.Distributed.gather!-Union{Tuple{N}, Tuple{T}, Tuple{Union{Nothing, AbstractArray{T, N}}, AbstractArray{T, N}, MPI.Comm}} where {T, N}",href:"#Chmy.Distributed.gather!-Union{Tuple{N}, Tuple{T}, Tuple{Union{Nothing, AbstractArray{T, N}}, AbstractArray{T, N}, MPI.Comm}} where {T, N}"},[e("span",{class:"jlbinding"},"Chmy.Distributed.gather!")],-1)),s[515]||(s[515]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[517]||(s[517]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">gather!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dst, src, comm</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MPI.Comm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; root</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Gather local array <code>src</code> into a global array <code>dst</code>. Size of the global array <code>size(dst)</code> should be equal to the product of the size of a local array <code>size(src)</code> and the dimensions of a Cartesian communicator <code>comm</code>. The array will be gathered on the process with id <code>root</code> (<code>root=0</code> by default). Note that the memory for a global array should be allocated only on the process with id <code>root</code>, on other processes <code>dst</code> can be set to <code>nothing</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[516]||(s[516]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/gather.jl#L1-L8",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Ie,[e("summary",null,[s[518]||(s[518]=e("a",{id:"Chmy.Distributed.global_rank-Tuple{CartesianTopology}",href:"#Chmy.Distributed.global_rank-Tuple{CartesianTopology}"},[e("span",{class:"jlbinding"},"Chmy.Distributed.global_rank")],-1)),s[519]||(s[519]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[521]||(s[521]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">global_rank</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(topo)</span></span></code></pre></div><p>Global id of a process in a Cartesian topology.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[520]||(s[520]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/topology.jl#L43-L47",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Pe,[e("summary",null,[s[522]||(s[522]=e("a",{id:"Chmy.Distributed.global_size-Tuple{CartesianTopology}",href:"#Chmy.Distributed.global_size-Tuple{CartesianTopology}"},[e("span",{class:"jlbinding"},"Chmy.Distributed.global_size")],-1)),s[523]||(s[523]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[525]||(s[525]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">global_size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(topo)</span></span></code></pre></div><p>Total number of processes within the topology.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[524]||(s[524]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/topology.jl#L115-L119",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Ge,[e("summary",null,[s[526]||(s[526]=e("a",{id:"Chmy.Distributed.has_neighbor-Tuple{CartesianTopology, Any, Any}",href:"#Chmy.Distributed.has_neighbor-Tuple{CartesianTopology, Any, Any}"},[e("span",{class:"jlbinding"},"Chmy.Distributed.has_neighbor")],-1)),s[527]||(s[527]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[529]||(s[529]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">has_neighbor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(topo, dim, side)</span></span></code></pre></div><p>Returns true if there a neighbor process in spatial direction <code>dim</code> on the side <code>side</code>, or false otherwise.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[528]||(s[528]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/topology.jl#L108-L112",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Ve,[e("summary",null,[s[530]||(s[530]=e("a",{id:"Chmy.Distributed.is_gpu_aware-Tuple{DistributedArchitecture}",href:"#Chmy.Distributed.is_gpu_aware-Tuple{DistributedArchitecture}"},[e("span",{class:"jlbinding"},"Chmy.Distributed.is_gpu_aware")],-1)),s[531]||(s[531]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[533]||(s[533]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">is_gpu_aware</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DistributedArchitecture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Whether the DistributedArchitecture is GPU-aware.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[532]||(s[532]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/distributed_architecture.jl#L43-L47",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Oe,[e("summary",null,[s[534]||(s[534]=e("a",{id:"Chmy.Distributed.nallocs-Tuple{Chmy.Distributed.StackAllocator}",href:"#Chmy.Distributed.nallocs-Tuple{Chmy.Distributed.StackAllocator}"},[e("span",{class:"jlbinding"},"Chmy.Distributed.nallocs")],-1)),s[535]||(s[535]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[537]||(s[537]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nallocs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sa</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StackAllocator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the number of allocations made by the given <code>StackAllocator</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[536]||(s[536]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/stack_allocator.jl#L50-L54",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Le,[e("summary",null,[s[538]||(s[538]=e("a",{id:"Chmy.Distributed.neighbor-Tuple{CartesianTopology, Any, Any}",href:"#Chmy.Distributed.neighbor-Tuple{CartesianTopology, Any, Any}"},[e("span",{class:"jlbinding"},"Chmy.Distributed.neighbor")],-1)),s[539]||(s[539]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[541]||(s[541]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">neighbor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(topo, dim, side)</span></span></code></pre></div><p>Returns id of a neighbor process in spatial direction <code>dim</code> on the side <code>side</code>, if this neighbor exists, or MPI.PROC_NULL otherwise.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[540]||(s[540]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/topology.jl#L101-L105",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Be,[e("summary",null,[s[542]||(s[542]=e("a",{id:"Chmy.Distributed.neighbors-Tuple{CartesianTopology}",href:"#Chmy.Distributed.neighbors-Tuple{CartesianTopology}"},[e("span",{class:"jlbinding"},"Chmy.Distributed.neighbors")],-1)),s[543]||(s[543]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[545]||(s[545]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">neighbors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(topo)</span></span></code></pre></div><p>Neighbors of a current process.</p><p>Returns tuple of ranks of the two immediate neighbors in each spatial direction, or MPI.PROC_NULL if there is no neighbor on a corresponding side.</p>',3)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[544]||(s[544]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/topology.jl#L92-L98",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",we,[e("summary",null,[s[546]||(s[546]=e("a",{id:"Chmy.Distributed.node_name-Tuple{CartesianTopology}",href:"#Chmy.Distributed.node_name-Tuple{CartesianTopology}"},[e("span",{class:"jlbinding"},"Chmy.Distributed.node_name")],-1)),s[547]||(s[547]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[549]||(s[549]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">node_name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(topo)</span></span></code></pre></div><p>Name of a node according to <code>MPI.Get_processor_name()</code>.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[548]||(s[548]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/topology.jl#L57-L61",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Me,[e("summary",null,[s[550]||(s[550]=e("a",{id:"Chmy.Distributed.node_size-Tuple{CartesianTopology}",href:"#Chmy.Distributed.node_size-Tuple{CartesianTopology}"},[e("span",{class:"jlbinding"},"Chmy.Distributed.node_size")],-1)),s[551]||(s[551]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[553]||(s[553]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">node_size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(topo)</span></span></code></pre></div><p>Number of processes sharing the same node.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[552]||(s[552]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/topology.jl#L122-L126",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Ue,[e("summary",null,[s[554]||(s[554]=e("a",{id:"Chmy.Distributed.reset!-Tuple{Chmy.Distributed.StackAllocator}",href:"#Chmy.Distributed.reset!-Tuple{Chmy.Distributed.StackAllocator}"},[e("span",{class:"jlbinding"},"Chmy.Distributed.reset!")],-1)),s[555]||(s[555]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[557]||(s[557]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">reset!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sa</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StackAllocator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Reset the stack allocator by resetting the pointer. Doesn&#39;t free the internal memory buffer.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[556]||(s[556]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/stack_allocator.jl#L23-L27",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Re,[e("summary",null,[s[558]||(s[558]=e("a",{id:"Chmy.Distributed.shared_comm-Tuple{CartesianTopology}",href:"#Chmy.Distributed.shared_comm-Tuple{CartesianTopology}"},[e("span",{class:"jlbinding"},"Chmy.Distributed.shared_comm")],-1)),s[559]||(s[559]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[561]||(s[561]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">shared_comm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(topo)</span></span></code></pre></div><p>MPI communicator for the processes sharing the same node.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[560]||(s[560]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/topology.jl#L71-L75",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",ze,[e("summary",null,[s[562]||(s[562]=e("a",{id:"Chmy.Distributed.shared_rank-Tuple{CartesianTopology}",href:"#Chmy.Distributed.shared_rank-Tuple{CartesianTopology}"},[e("span",{class:"jlbinding"},"Chmy.Distributed.shared_rank")],-1)),s[563]||(s[563]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[565]||(s[565]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">shared_rank</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(topo)</span></span></code></pre></div><p>Local id of a process within a single node. Can be used to set the GPU device.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[564]||(s[564]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/topology.jl#L50-L54",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",Ke,[e("summary",null,[s[566]||(s[566]=e("a",{id:"Chmy.Distributed.topology-Tuple{DistributedArchitecture}",href:"#Chmy.Distributed.topology-Tuple{DistributedArchitecture}"},[e("span",{class:"jlbinding"},"Chmy.Distributed.topology")],-1)),s[567]||(s[567]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[569]||(s[569]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">topology</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DistributedArchitecture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the virtual MPI topology of a distributed architecture</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[568]||(s[568]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/distributed_architecture.jl#L36-L40",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",qe,[e("summary",null,[s[570]||(s[570]=e("a",{id:"KernelAbstractions.get_backend-Tuple{DistributedArchitecture}",href:"#KernelAbstractions.get_backend-Tuple{DistributedArchitecture}"},[e("span",{class:"jlbinding"},"KernelAbstractions.get_backend")],-1)),s[571]||(s[571]=a()),t(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[573]||(s[573]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_backend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DistributedArchitecture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Get the backend associated with a DistributedArchitecture by delegating to the child architecture.</p>',2)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[572]||(s[572]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Distributed/distributed_architecture.jl#L51-L55",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[586]||(s[586]=e("h2",{id:"workers",tabindex:"-1"},[a("Workers "),e("a",{class:"header-anchor",href:"#workers","aria-label":'Permalink to "Workers"'},"​")],-1)),e("details",We,[e("summary",null,[s[574]||(s[574]=e("a",{id:"Chmy.Workers.Worker",href:"#Chmy.Workers.Worker"},[e("span",{class:"jlbinding"},"Chmy.Workers.Worker")],-1)),s[575]||(s[575]=a()),t(i,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[577]||(s[577]=r('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Worker</span></span></code></pre></div><p>A worker that performs tasks asynchronously.</p><p><strong>Constructor</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Worker{T}(; [setup], [teardown]) where {T}</span></span></code></pre></div><p>Constructs a new <code>Worker</code> object.</p><p><strong>Arguments</strong></p><ul><li><p><code>setup</code>: A function to be executed before the worker starts processing tasks. (optional)</p></li><li><p><code>teardown</code>: A function to be executed after the worker finishes processing tasks. (optional)</p></li></ul>',7)),t(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[576]||(s[576]=[e("a",{href:"https://github.com/PTsolvers/Chmy.jl/blob/de4cf33c03803378115b1a110c7a841aecd07a59/src/Workers.jl#L5-L18",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const ei=n(h,[["render",$e]]);export{si as __pageData,ei as default};
