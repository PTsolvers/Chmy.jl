import{_ as i,c as a,o as e,aA as t}from"./chunks/framework.BA5u_Yub.js";const g=JSON.parse('{"title":"Kernels","description":"","frontmatter":{},"headers":[],"relativePath":"concepts/kernels.md","filePath":"concepts/kernels.md","lastUpdated":null}'),n={name:"concepts/kernels.md"};function l(h,s,k,p,r,d){return e(),a("div",null,[...s[0]||(s[0]=[t(`<h1 id="kernels" tabindex="-1">Kernels <a class="header-anchor" href="#kernels" aria-label="Permalink to &quot;Kernels&quot;">​</a></h1><p>The <a href="https://github.com/JuliaGPU/KernelAbstractions.jl" target="_blank" rel="noreferrer">KernelAbstractions.jl</a> package provides a macro-based dialect that hides the intricacies of vendor-specific GPU programming. It allows one to write hardware-agnostic kernels that can be instantiated and launched for different device backends without modifying the high-level code nor sacrificing performance.</p><p>In the following, we show how to write and launch kernels on various backends. We also explain the concept of a <code>Launcher</code> in <a href="https://github.com/PTsolvers/Chmy.jl" target="_blank" rel="noreferrer">Chmy.jl</a>, that complements the default kernel launching, allowing us to hide the latency between the bulk of the computations and boundary conditions or MPI communications.</p><h2 id="Writing-Kernels" tabindex="-1">Writing Kernels <a class="header-anchor" href="#Writing-Kernels" aria-label="Permalink to &quot;Writing Kernels {#Writing-Kernels}&quot;">​</a></h2><p>This section highlights some important features of <a href="https://github.com/JuliaGPU/KernelAbstractions.jl" target="_blank" rel="noreferrer">KernelAbstractions.jl</a> that are essential for understanding the high-level abstraction of the kernel concept that is used throughout our package. As it barely serves for illustrative purposes, for more specific examples, please refer to their <a href="https://juliagpu.github.io/KernelAbstractions.jl/stable/" target="_blank" rel="noreferrer">documentation</a>.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> KernelAbstractions</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Define a kernel that performs element-wise operations on A</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@kernel</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mul2!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(A)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # use @index macro to obtain the global Cartesian index of the current work item.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    I </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> @index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Global, Cartesian)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    A[I] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>The kernel <code>mul2!</code> being defined using the <code>@kernel</code> macro, we can launch it on the desired backend to perform the element-wise operations on host.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Define array and work group size</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">A       </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ones</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">backend </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> get_backend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(A) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># CPU</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Launch kernel and explicitly synchronize</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kernel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> mul2!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">kernel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(A, ndrange</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(A))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">KernelAbstractions</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">synchronize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Result assertion</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@assert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">all</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(A </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>To launch the kernel on GPU devices, one could simply define <code>A</code> as <code>CuArray</code>, <code>ROCArray</code> or <code>oneArray</code> as detailed in the section <a href="https://juliagpu.github.io/KernelAbstractions.jl/stable/quickstart/#Launching-kernel-on-the-backend" target="_blank" rel="noreferrer">&quot;launching kernel on the backend&quot;</a>. More fine-grained memory access is available using the <code>@index</code> macro as described <a href="https://juliagpu.github.io/KernelAbstractions.jl/stable/api/#KernelAbstractions.@index" target="_blank" rel="noreferrer">here</a>.</p><h3 id="Thread-Indexing" tabindex="-1">Thread Indexing <a class="header-anchor" href="#Thread-Indexing" aria-label="Permalink to &quot;Thread Indexing {#Thread-Indexing}&quot;">​</a></h3><p>Thread indexing is essential for memory usage on GPU devices; however, it can quickly become cumbersome to figure out the thread index, especially when working with multi-dimensional grids of multi-dimensional blocks of threads. The performance of kernels can also depend significantly on access patterns.</p><p>In the example above, we saw the usage of <code>I = @index(Global, Cartesian)</code>, which retrieves the global index of threads for the two-dimensional array <code>A</code>. Such powerful macros are provided by <a href="https://github.com/JuliaGPU/KernelAbstractions.jl" target="_blank" rel="noreferrer">KernelAbstractions.jl</a> for conveniently retrieving the desired index of threads.</p><p>The following table is non-exhaustive and provides a reference of commonly used terminology. Here, <a href="https://juliagpu.github.io/KernelAbstractions.jl/stable/api/#KernelAbstractions.@index" target="_blank" rel="noreferrer"><code>KernelAbstractions.@index</code></a> is used for index retrieval, and <a href="https://juliagpu.github.io/KernelAbstractions.jl/stable/api/#KernelAbstractions.@groupsize" target="_blank" rel="noreferrer"><code>KernelAbstractions.@groupsize</code></a> is used for obtaining the dimensions of blocks of threads.</p><table tabindex="0"><thead><tr><th style="text-align:right;">KernelAbstractions</th><th style="text-align:right;">CPU</th><th style="text-align:right;">CUDA</th><th style="text-align:right;">AMDGPU</th></tr></thead><tbody><tr><td style="text-align:right;"><code>@index(Local, Linear)</code></td><td style="text-align:right;"><code>mod(i, g)</code></td><td style="text-align:right;"><code>threadIdx().x</code></td><td style="text-align:right;"><code>workitemIdx().x</code></td></tr><tr><td style="text-align:right;"><code>@index(Local, Cartesian)[2]</code></td><td style="text-align:right;"></td><td style="text-align:right;"><code>threadIdx().y</code></td><td style="text-align:right;"><code>workitemIdx().y</code></td></tr><tr><td style="text-align:right;"><code>@index(Local, Cartesian)[3]</code></td><td style="text-align:right;"></td><td style="text-align:right;"><code>threadIdx().z</code></td><td style="text-align:right;"><code>workitemIdx().z</code></td></tr><tr><td style="text-align:right;"><code>@index(Group, Linear)</code></td><td style="text-align:right;"><code>i ÷ g</code></td><td style="text-align:right;"><code>blockIdx().x</code></td><td style="text-align:right;"><code>workgroupIdx().x</code></td></tr><tr><td style="text-align:right;"><code>@index(Group, Cartesian)[2]</code></td><td style="text-align:right;"></td><td style="text-align:right;"><code>blockIdx().y</code></td><td style="text-align:right;"><code>workgroupIdx().y</code></td></tr><tr><td style="text-align:right;"><code>@groupsize()[3]</code></td><td style="text-align:right;"></td><td style="text-align:right;"><code>blockDim().z</code></td><td style="text-align:right;"><code>workgroupDim().z</code></td></tr><tr><td style="text-align:right;"><code>@index(Global, Linear)</code></td><td style="text-align:right;"><code>i</code></td><td style="text-align:right;">global index computation needed</td><td style="text-align:right;">global index computation needed</td></tr><tr><td style="text-align:right;"><code>@index(Global, Cartesian)[2]</code></td><td style="text-align:right;"></td><td style="text-align:right;">global index computation needed</td><td style="text-align:right;">global index computation needed</td></tr><tr><td style="text-align:right;"><code>@index(Global, NTuple)</code></td><td style="text-align:right;"></td><td style="text-align:right;">global index computation needed</td><td style="text-align:right;">global index computation needed</td></tr></tbody></table><p>The <code>@index(Global, NTuple)</code> returns a <code>NTuple</code> object, allowing more fine-grained memory control over the allocated arrays.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@kernel</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> memcpy!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a, b)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    i, j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> @index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Global, NTuple)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    @inbounds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a[i, j] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b[i, j]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>A tuple can be splatted with <a href="https://docs.julialang.org/en/v1/manual/faq/#What-does-the-...-operator-do?" target="_blank" rel="noreferrer"><code>...</code></a> Julia operator when used to avoid explicitly using <code>i</code>, <code>j</code> indices.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@kernel</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> splatting_memcpy!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a, b)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    I </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> @index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Global, NTuple)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    @inbounds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a[I</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b[I</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><h2 id="Kernel-Launcher" tabindex="-1">Kernel Launcher <a class="header-anchor" href="#Kernel-Launcher" aria-label="Permalink to &quot;Kernel Launcher {#Kernel-Launcher}&quot;">​</a></h2><p>In <a href="https://github.com/PTsolvers/Chmy.jl" target="_blank" rel="noreferrer">Chmy.jl</a>, the <code>KernelLaunch</code> module is designed to provide handy utilities for performing different grid operations on selected data entries of <code>Field</code>s that are involved at each kernel launch, in which the grid geometry underneath is also taken into account.</p><p>Followingly, we define a kernel launcher associated with an <code>UniformGrid</code> object, supporting CUDA backend.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Define backend and geometry</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Arch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CUDABackend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">grid </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UniformGrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arch; origin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), extent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), dims</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">126</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">126</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Define launcher</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">launch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Launcher</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arch, grid)</span></span></code></pre></div><p>We also have two kernel functions <code>compute_q!</code> and <code>update_C!</code> defined, which shall update the fields <code>q</code> and <code>C</code> using grid operators (see section <a href="./grid_operators">Grid Operators</a>) <code>∂x</code>, <code>∂y</code>, <code>divg</code> that are anchored on some grid <code>g</code> accordingly.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@kernel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inbounds </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compute_q!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(q, C, χ, g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StructuredGrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, O)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    I </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> @index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Global, Cartesian)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    I </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> I </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> O</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    q</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x[I] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">χ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ∂x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(C, g, I)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    q</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">y[I] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">χ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ∂y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(C, g, I)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@kernel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inbounds </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> update_C!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(C, q, Δt, g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StructuredGrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, O)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    I </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> @index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Global, Cartesian)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    I </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> I </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> O</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    C[I] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Δt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> divg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(q, g, I)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>To spawn the kernel, we invoke the launcher using the <code>launch</code> function to perform the field update at each physical timestep, and specify desired boundary conditions for involved fields in the kernel.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Define physics, numerics, geometry ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> it </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nt</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # without boundary conditions</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arch, grid, compute_q! </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (q, C, χ, grid))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # with Neumann boundary conditions and MPI exchange</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    launch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arch, grid, update_C! </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (C, q, Δt, grid); bc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">batch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid, C </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Neumann</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); exchange</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">C))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div>`,26)])])}const c=i(n,[["render",l]]);export{g as __pageData,c as default};
