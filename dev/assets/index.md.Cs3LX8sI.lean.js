import{_ as i,c as a,o as t,aA as n}from"./chunks/framework.BA5u_Yub.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{"layout":"home","hero":{"name":"Chmy.jl Docs","text":"Finite differences and staggered grids on CPUs and GPUs","tagline":"A backend-agnostic toolkit for finite difference computations with task-based distributed memory parallelisation.","actions":[{"theme":"brand","text":"Getting Started","link":"/getting_started/introduction"},{"theme":"alt","text":"API Reference 📚","link":"/lib/modules"},{"theme":"alt","text":"View on GitHub","link":"https://github.com/PTsolvers/Chmy.jl"}],"image":{"src":"/logo.png","alt":"Chmy.jl"}},"features":[{"icon":"🚀","title":"Backend Agnostic","details":"Effortlessly execute your code on CPUs and GPUs with KernelAbstractions.jl.","link":"/concepts/architectures"},{"icon":"⚡","title":"Multi-device","details":"Leverages task-based distributed memory parallelisation capabilities with MPI.jl.","link":"/concepts/distributed"},{"icon":"🛠️","title":"Framework","details":"Fields, boundary conditions and interpolation operators on structured grids.","link":"/getting_started/introduction"},{"icon":"🧩","title":"Extensibility","details":"Written in pure Julia, adding new functions, simplification rules, and model transformations has no barrier.","link":"/concepts/kernels"}]},"headers":[],"relativePath":"index.md","filePath":"index.md","lastUpdated":null}'),e={name:"index.md"};function l(h,s,p,k,r,d){return t(),a("div",null,[...s[0]||(s[0]=[n("",13)])])}const g=i(e,[["render",l]]);export{c as __pageData,g as default};
