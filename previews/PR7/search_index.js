var documenterSearchIndex = {"docs":
[{"location":"lib/modules/#Modules","page":"Modules","title":"Modules","text":"","category":"section"},{"location":"lib/modules/#Grids","page":"Modules","title":"Grids","text":"","category":"section"},{"location":"lib/modules/","page":"Modules","title":"Modules","text":"Modules = [Chmy.Grids]\nOrder   = [:type, :function]","category":"page"},{"location":"lib/modules/#Chmy.Grids.StructuredGrid","page":"Modules","title":"Chmy.Grids.StructuredGrid","text":"struct StructuredGrid{N,T,C,A}\n\nRepresents a structured grid with orthogonal axes.\n\n\n\n\n\n","category":"type"},{"location":"lib/modules/#Chmy.Grids.UniformGrid-Union{Tuple{Chmy.Architectures.Architecture}, Tuple{N}} where N","page":"Modules","title":"Chmy.Grids.UniformGrid","text":"UniformGrid(arch; origin, extent, dims, topology=nothing) where {N}\n\nConstructs a uniform grid with specified origin, extent, dimensions, and topology.\n\nArguments\n\narch::Architecture: The associated architecture.\norigin::NTuple{N,Number}: The origin of the grid.\nextent::NTuple{N,Number}: The extent of the grid.\ndims::NTuple{N,Integer}: The dimensions of the grid.\ntopology=nothing: The topology of the grid. If not provided, a default Bounded topology is used.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Grids.axis-Union{Tuple{dim}, Tuple{Chmy.Grids.StructuredGrid, Val{dim}}} where dim","page":"Modules","title":"Chmy.Grids.axis","text":"axis(grid::RegularGrid, ::Val{dim}) where {dim}\n\nReturn the axis corresponding to the spatial dimension dim.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Grids.bounds-Union{Tuple{N}, Tuple{Chmy.Grids.StructuredGrid{N}, Union{Tuple{Vararg{Chmy.Grids.Location, N}}, Chmy.Grids.Location}}} where N","page":"Modules","title":"Chmy.Grids.bounds","text":"bounds(grid::StructuredGrid{N}, loc::LocOrLocs{N}) where {N}\n\nCompute the bounds of a structured grid at the specified location(s).\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Grids.connectivity-Union{Tuple{S}, Tuple{D}, Tuple{C}, Tuple{T}, Tuple{N}, Tuple{Chmy.Grids.StructuredGrid{N, T, C}, Val{D}, Val{S}}} where {N, T, C, D, S}","page":"Modules","title":"Chmy.Grids.connectivity","text":"connectivity(grid::StructuredGrid{N,T,C}, D::Val, S::Val)\n\nReturn the connectivity of the structured grid grid for the given dimension D and side S.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Grids.coord-Union{Tuple{N}, Tuple{Chmy.Grids.StructuredGrid{N}, Chmy.Grids.Location, Vararg{Integer, N}}} where N","page":"Modules","title":"Chmy.Grids.coord","text":"coord(grid::RegularGrid{N}, loc::[Location, NTuple{N,Location}], I...) where {N}\n\nReturn a tuple of spatial coordinates of a grid point at location loc and indices I.\n\nFor vertex locations, first grid point is at the origin. For center locations, first grid point at half-spacing distance from the origin.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Grids.inv_spacing-Union{Tuple{N}, Tuple{Chmy.Grids.StructuredGrid{N}, Chmy.Grids.Location, Vararg{Integer, N}}} where N","page":"Modules","title":"Chmy.Grids.inv_spacing","text":"inv_spacing(grid::RegularGrid{N}, loc::[Location, NTuple{N,Location}], I...) where {N}\n\nReturn a tuple of inverse grid spacings at location loc and indices I.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Grids.spacing-Union{Tuple{N}, Tuple{Chmy.Grids.StructuredGrid{N}, Chmy.Grids.Location, Vararg{Integer, N}}} where N","page":"Modules","title":"Chmy.Grids.spacing","text":"spacing(grid::RegularGrid{N}, loc::[Location, NTuple{N,Location}], I...) where {N}\n\nReturn a tuple of grid spacings at location loc and indices I.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Architectures","page":"Modules","title":"Architectures","text":"","category":"section"},{"location":"lib/modules/","page":"Modules","title":"Modules","text":"Modules = [Chmy.Architectures]\nOrder   = [:type, :function]","category":"page"},{"location":"lib/modules/#Chmy.Architectures.Architecture","page":"Modules","title":"Chmy.Architectures.Architecture","text":"abstract type Architecture\n\nAbstract type representing an architecture.\n\n\n\n\n\n","category":"type"},{"location":"lib/modules/#Chmy.Architectures.SingleDeviceArchitecture","page":"Modules","title":"Chmy.Architectures.SingleDeviceArchitecture","text":"struct SingleDeviceArchitecture{B,D} <: Architecture\n\nA struct representing an architecture that operates on a single CPU or GPU device.\n\n\n\n\n\n","category":"type"},{"location":"lib/modules/#Chmy.Architectures.Arch-Tuple{KernelAbstractions.Backend}","page":"Modules","title":"Chmy.Architectures.Arch","text":"Arch(backend::Backend; device_id::Integer=1)\n\nCreate an architecture object for the specified backend and device.\n\nArguments\n\nbackend: The backend to use for computation.\ndevice_id=1: The ID of the device to use.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Architectures.activate!-Tuple{Chmy.Architectures.SingleDeviceArchitecture}","page":"Modules","title":"Chmy.Architectures.activate!","text":"activate!(arch::SingleDeviceArchitecture; priority=:normal)\n\nActivate the given architecture on the specified device and set the priority of the backend.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Architectures.get_backend-Tuple{Chmy.Architectures.SingleDeviceArchitecture}","page":"Modules","title":"Chmy.Architectures.get_backend","text":"get_backend(arch::SingleDeviceArchitecture)\n\nGet the backend associated with a SingleDeviceArchitecture.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Architectures.get_device-Tuple{Chmy.Architectures.SingleDeviceArchitecture}","page":"Modules","title":"Chmy.Architectures.get_device","text":"get_device(arch::SingleDeviceArchitecture)\n\nGet the device associated with a SingleDeviceArchitecture.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Fields","page":"Modules","title":"Fields","text":"","category":"section"},{"location":"lib/modules/","page":"Modules","title":"Modules","text":"Modules = [Chmy.Fields]\nOrder   = [:type, :function]","category":"page"},{"location":"lib/modules/#Chmy.Fields.ConstantField","page":"Modules","title":"Chmy.Fields.ConstantField","text":"Scalar field with a constant value\n\n\n\n\n\n","category":"type"},{"location":"lib/modules/#Chmy.Fields.Field","page":"Modules","title":"Chmy.Fields.Field","text":"struct Field{T,N,L,H,A} <: AbstractField{T,N,L}\n\nField represents a discrete scalar field with specified type, number of dimensions, location, and halo size.\n\n\n\n\n\n","category":"type"},{"location":"lib/modules/#Chmy.Fields.Field-Union{Tuple{N}, Tuple{KernelAbstractions.Backend, Chmy.Grids.StructuredGrid{N}, Union{Tuple{Vararg{Chmy.Grids.Location, N}}, Chmy.Grids.Location}}, Tuple{KernelAbstractions.Backend, Chmy.Grids.StructuredGrid{N}, Union{Tuple{Vararg{Chmy.Grids.Location, N}}, Chmy.Grids.Location}, Any}} where N","page":"Modules","title":"Chmy.Fields.Field","text":"Field(backend, grid, loc, type=eltype(grid); halo=1)\n\nConstructs a field on a structured grid at the specified location.\n\nArguments:\n\nbackend: The backend to use for memory allocation.\ngrid: The structured grid on which the field is constructed.\nloc: The location or locations on the grid where the field is constructed.\ntype: The element type of the field. Defaults to the element type of the grid.\nhalo: The halo size for the field. Defaults to 1.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Fields.FunctionField","page":"Modules","title":"Chmy.Fields.FunctionField","text":"struct FunctionField{T,N,L,CD,F,G,P} <: AbstractField{T,N,L}\n\nContinuous or discrete field with values computed at runtime.\n\nConstructors\n\nFunctionField{CD,L}(func::F, grid::G, parameters::P) where {CD,L,F,G,P}: Create a new FunctionField object.\n\n\n\n\n\n","category":"type"},{"location":"lib/modules/#Chmy.Fields.OneField","page":"Modules","title":"Chmy.Fields.OneField","text":"Constant field with values equal to one(T)\n\n\n\n\n\n","category":"type"},{"location":"lib/modules/#Chmy.Fields.ValueField","page":"Modules","title":"Chmy.Fields.ValueField","text":"Field with a constant value\n\n\n\n\n\n","category":"type"},{"location":"lib/modules/#Chmy.Fields.ZeroField","page":"Modules","title":"Chmy.Fields.ZeroField","text":"Constant field with values equal to zero(T)\n\n\n\n\n\n","category":"type"},{"location":"lib/modules/#Grid-Operators","page":"Modules","title":"Grid Operators","text":"","category":"section"},{"location":"lib/modules/","page":"Modules","title":"Modules","text":"Modules = [Chmy.GridOperators]\nOrder   = [:type, :function]","category":"page"},{"location":"lib/modules/#Chmy.GridOperators.leftx-Union{Tuple{N}, Tuple{Any, Any, Vararg{Integer, N}}} where N","page":"Modules","title":"Chmy.GridOperators.leftx","text":"leftx(f, loc, I)\n\n\"left side\" of a field ([1:end-1]) in x direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.GridOperators.lefty-Union{Tuple{N}, Tuple{Any, Any, Vararg{Integer, N}}} where N","page":"Modules","title":"Chmy.GridOperators.lefty","text":"lefty(f, loc, I)\n\n\"left side\" of a field ([1:end-1]) in y direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.GridOperators.leftz-Union{Tuple{N}, Tuple{Any, Any, Vararg{Integer, N}}} where N","page":"Modules","title":"Chmy.GridOperators.leftz","text":"leftz(f, loc, I)\n\n\"left side\" of a field ([1:end-1]) in z direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.GridOperators.rightx-Union{Tuple{N}, Tuple{Any, Any, Vararg{Integer, N}}} where N","page":"Modules","title":"Chmy.GridOperators.rightx","text":"rightx(f, loc, I)\n\n\"right side\" of a field ([2:end]) in x direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.GridOperators.righty-Union{Tuple{N}, Tuple{Any, Any, Vararg{Integer, N}}} where N","page":"Modules","title":"Chmy.GridOperators.righty","text":"righty(f, loc, I)\n\n\"right side\" of a field ([2:end]) in y direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.GridOperators.rightz-Union{Tuple{N}, Tuple{Any, Any, Vararg{Integer, N}}} where N","page":"Modules","title":"Chmy.GridOperators.rightz","text":"rightz(f, loc, I)\n\n\"right side\" of a field ([2:end]) in z direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.GridOperators.δx-Union{Tuple{N}, Tuple{Any, Any, Vararg{Integer, N}}} where N","page":"Modules","title":"Chmy.GridOperators.δx","text":"δx(f, loc, I)\n\nFinite difference in x direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.GridOperators.δy-Union{Tuple{N}, Tuple{Any, Any, Vararg{Integer, N}}} where N","page":"Modules","title":"Chmy.GridOperators.δy","text":"δy(f, loc, I)\n\nFinite difference in y direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.GridOperators.δz-Union{Tuple{N}, Tuple{Any, Any, Vararg{Integer, N}}} where N","page":"Modules","title":"Chmy.GridOperators.δz","text":"δz(f, loc, I)\n\nFinite difference in z direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.GridOperators.∂x-Union{Tuple{N}, Tuple{Any, Any, Any, Vararg{Integer, N}}} where N","page":"Modules","title":"Chmy.GridOperators.∂x","text":"∂x(f, loc, grid, I)\n\nDirectional partial derivative in x direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.GridOperators.∂y-Union{Tuple{N}, Tuple{Any, Any, Any, Vararg{Integer, N}}} where N","page":"Modules","title":"Chmy.GridOperators.∂y","text":"∂y(f, loc, grid, I)\n\nDirectional partial derivative in y direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.GridOperators.∂z-Union{Tuple{N}, Tuple{Any, Any, Any, Vararg{Integer, N}}} where N","page":"Modules","title":"Chmy.GridOperators.∂z","text":"∂z(f, loc, grid, I)\n\nDirectional partial derivative in z direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Boundary-Conditions","page":"Modules","title":"Boundary Conditions","text":"","category":"section"},{"location":"lib/modules/","page":"Modules","title":"Modules","text":"Modules = [Chmy.BoundaryConditions]\nOrder   = [:type, :function]","category":"page"},{"location":"lib/modules/#Chmy.BoundaryConditions.AbstractBatch","page":"Modules","title":"Chmy.BoundaryConditions.AbstractBatch","text":"abstract type AbstractBatch\n\nAbstract type representing a batch of boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"lib/modules/#Chmy.BoundaryConditions.EmptyBatch","page":"Modules","title":"Chmy.BoundaryConditions.EmptyBatch","text":"struct EmptyBatch <: AbstractBatch\n\nEmptyBatch represents no boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"lib/modules/#Chmy.BoundaryConditions.bc!-Union{Tuple{N}, Tuple{Chmy.Architectures.Architecture, Chmy.Grids.StructuredGrid{N}, Tuple{Vararg{Tuple{Chmy.BoundaryConditions.AbstractBatch, Chmy.BoundaryConditions.AbstractBatch}, N}}}} where N","page":"Modules","title":"Chmy.BoundaryConditions.bc!","text":"bc!(arch::Architecture, grid::StructuredGrid, batch::BatchSet)\n\nApply boundary conditions using a batch set batch containing an AbstractBatch per dimension per side of grid.\n\nArguments\n\narch: The architecture.\ngrid: The grid.\nbatch:: The batch set to apply boundary conditions to.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Distributed","page":"Modules","title":"Distributed","text":"","category":"section"},{"location":"lib/modules/","page":"Modules","title":"Modules","text":"Modules = [Chmy.Distributed]\nOrder   = [:type, :function]","category":"page"},{"location":"lib/modules/#Chmy.Distributed.CartesianTopology","page":"Modules","title":"Chmy.Distributed.CartesianTopology","text":"CartesianTopology\n\nRepresents N-dimensional Cartesian topology of distributed processes.\n\n\n\n\n\n","category":"type"},{"location":"lib/modules/#Chmy.Distributed.CartesianTopology-Union{Tuple{N}, Tuple{MPI.Comm, Tuple{Vararg{Int64, N}}}} where N","page":"Modules","title":"Chmy.Distributed.CartesianTopology","text":"CartesianTopology(comm::MPI.Comm, dims::NTuple{N,Int}) where {N}\n\nCreate an N-dimensional Cartesian topology using base MPI communicator comm with dimensions dims. If all entries in dims are not equal to 0, the product of dims should be equal to the total number of MPI processes MPI.Comm_size(comm). If any (or all) entries of dims are 0, the dimensions in the corresponding spatial directions will be picked automatically.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Distributed.DistributedArchitecture","page":"Modules","title":"Chmy.Distributed.DistributedArchitecture","text":"struct DistributedArchitecture{ChildArch,Topo}\n\nA struct representing a distributed architecture.\n\n\n\n\n\n","category":"type"},{"location":"lib/modules/#Chmy.Distributed.StackAllocator","page":"Modules","title":"Chmy.Distributed.StackAllocator","text":"mutable struct StackAllocator\n\nSimple stack (a.k.a. bump/arena) allocator. Maintains an internal buffer that grows dynamically if the requested allocation exceeds current buffer size.\n\n\n\n\n\n","category":"type"},{"location":"lib/modules/#Chmy.Distributed.StackAllocator-Tuple{KernelAbstractions.Backend}","page":"Modules","title":"Chmy.Distributed.StackAllocator","text":"StackAllocator(backend::Backend)\n\nCreate a stack allocator using the specified backend to store allocations.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Architectures.Arch-Tuple{KernelAbstractions.Backend, MPI.Comm, Any}","page":"Modules","title":"Chmy.Architectures.Arch","text":"Arch(backend::Backend, comm::MPI::Comm, dims; kwargs...) where {N}\n\nCreate a distributed Architecture using backend backend and comm. For GPU backends, device will be selected automatically based on a process id within a node.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Distributed.allocate","page":"Modules","title":"Chmy.Distributed.allocate","text":"allocate(sa::StackAllocator, T::DataType, dims, [align=sizeof(T)])\n\nAllocate a buffer of type T with dimensions dims using a stack allocator. The align parameter specifies the alignment of the buffer elements.\n\nArguments\n\nsa::StackAllocator: The stack allocator object.\nT::DataType: The data type of the requested allocation.\ndims: The dimensions of the requested allocation.\nalign::Integer: The alignment of the allocated buffer in bytes.\n\nwarning: Warning\nArrays allocated with StackAllocator are not managed by Julia runtime. User is responsible for ensuring correct lifetimes, i.e., that the reference to allocator outlives all arrays allocated using this allocator.\n\n\n\n\n\n","category":"function"},{"location":"lib/modules/#Chmy.Distributed.cart_comm-Tuple{Chmy.Distributed.CartesianTopology}","page":"Modules","title":"Chmy.Distributed.cart_comm","text":"cart_comm(t::CartesianTopology)\n\nMPI Cartesian communicator for the topology.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Distributed.coords-Tuple{Chmy.Distributed.CartesianTopology}","page":"Modules","title":"Chmy.Distributed.coords","text":"coords(t::CartesianTopology)\n\nCoordinates of a current process within a Cartesian topology.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Distributed.dims-Tuple{Chmy.Distributed.CartesianTopology}","page":"Modules","title":"Chmy.Distributed.dims","text":"dims(t::CartesianTopology)\n\nDimensions of the topology as NTuple.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Distributed.gather!-Tuple{Chmy.Distributed.DistributedArchitecture, Any, Chmy.Fields.Field}","page":"Modules","title":"Chmy.Distributed.gather!","text":"gather!(arch::DistributedArchitecture, dst, src::Field; kwargs...)\n\nGather the interior of a field src into a global array dst.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Distributed.gather!-Union{Tuple{N}, Tuple{T}, Tuple{Union{Nothing, AbstractArray{T, N}}, AbstractArray{T, N}, MPI.Comm}} where {T, N}","page":"Modules","title":"Chmy.Distributed.gather!","text":"gather!(dst::Union{AbstractArray{T,N},Nothing}, src::AbstractArray{T,N}, comm::MPI.Comm; root=0) where {T,N}\n\nGather local array src into a global array dst. Size of the global array size(dst) should be equal to the product of the size of a local array size(src) and the dimensions of a Cartesian communicator comm. The array will be gathered on the process with id root (root=0 by default). Note that the memory for a global array should be allocated only on the process with id root, on other processes dst can be set to nothing.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Distributed.global_rank-Tuple{Chmy.Distributed.CartesianTopology}","page":"Modules","title":"Chmy.Distributed.global_rank","text":"global_rank(t::CartesianTopology)\n\nGlobal id of a process in a Cartesian topology.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Distributed.global_size-Tuple{Chmy.Distributed.CartesianTopology}","page":"Modules","title":"Chmy.Distributed.global_size","text":"global_size(t::CartesianTopology)\n\nTotal number of processes withing the topology.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Distributed.has_neighbor-Tuple{Chmy.Distributed.CartesianTopology, Any, Any}","page":"Modules","title":"Chmy.Distributed.has_neighbor","text":"has_neighbor(t::CartesianTopology, dim, side)\n\nReturns true if there a neighbor process in spatial direction dim on the side side, or false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Distributed.nallocs-Tuple{Chmy.Distributed.StackAllocator}","page":"Modules","title":"Chmy.Distributed.nallocs","text":"nallocs(sa::StackAllocator)\n\nGet the number of allocations made by the given StackAllocator.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Distributed.neighbor-Tuple{Chmy.Distributed.CartesianTopology, Any, Any}","page":"Modules","title":"Chmy.Distributed.neighbor","text":"neighbor(t::CartesianTopology, dim, side)\n\nReturns id of a neighbor process in spatial direction dim on the side side, if this neighbor exists, or MPI.PROC_NULL otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Distributed.neighbors-Tuple{Chmy.Distributed.CartesianTopology}","page":"Modules","title":"Chmy.Distributed.neighbors","text":"neighbors(t::CartesianTopology)\n\nNeighbors of a current process.\n\nReturns NTuple containing process ids of the two immediate neighbors in each spatial direction, or MPI.PROC_NULL if no neighbor on a corresponding side.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Distributed.node_name-Tuple{Chmy.Distributed.CartesianTopology}","page":"Modules","title":"Chmy.Distributed.node_name","text":"node_name(t::CartesianTopology)\n\nName of a node according to MPI.Get_processor_name().\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Distributed.node_size-Tuple{Chmy.Distributed.CartesianTopology}","page":"Modules","title":"Chmy.Distributed.node_size","text":"node_size(t::CartesianTopology)\n\nNumber of processes sharing the same node.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Distributed.reset!-Tuple{Chmy.Distributed.StackAllocator}","page":"Modules","title":"Chmy.Distributed.reset!","text":"reset!(sa::StackAllocator)\n\nReset the stack allocator by resetting the pointer. Doesn't free the internal memory buffer.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Distributed.shared_comm-Tuple{Chmy.Distributed.CartesianTopology}","page":"Modules","title":"Chmy.Distributed.shared_comm","text":"shared_comm(t::CartesianTopology)\n\nMPI communicator for the processes sharing the same node.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Chmy.Distributed.shared_rank-Tuple{Chmy.Distributed.CartesianTopology}","page":"Modules","title":"Chmy.Distributed.shared_rank","text":"shared_rank(t::CartesianTopology)\n\nLocal id of a process within a single node. Can be used to set the GPU device.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Workers","page":"Modules","title":"Workers","text":"","category":"section"},{"location":"lib/modules/","page":"Modules","title":"Modules","text":"Modules = [Chmy.Workers]\nOrder   = [:type, :function]","category":"page"},{"location":"lib/modules/#Chmy.Workers.Worker","page":"Modules","title":"Chmy.Workers.Worker","text":"mutable struct Worker{T}\n\nA worker that performs tasks asynchronously.\n\nConstructor\n\nWorker{T}(; setup=nothing, teardown=nothing) where {T}\n\nConstructs a new Worker object.\n\nArguments\n\nsetup: A function to be executed before the worker starts processing tasks. (optional)\nteardown: A function to be executed after the worker finishes processing tasks. (optional)\n\n\n\n\n\n","category":"type"},{"location":"usage/runtests/#Running-tests","page":"Running tests","title":"Running tests","text":"","category":"section"},{"location":"usage/runtests/#CPU-tests","page":"Running tests","title":"CPU tests","text":"","category":"section"},{"location":"usage/runtests/","page":"Running tests","title":"Running tests","text":"To run the Chmy test suite on the CPU, simple run test from within the package mode or using Pkg:","category":"page"},{"location":"usage/runtests/","page":"Running tests","title":"Running tests","text":"using Pkg\nPkg.test(\"Chmy\")","category":"page"},{"location":"usage/runtests/#GPU-tests","page":"Running tests","title":"GPU tests","text":"","category":"section"},{"location":"usage/runtests/","page":"Running tests","title":"Running tests","text":"To run the Chmy test suite on CUDA or ROC backend (Nvidia or AMD GPUs), respectively, run the tests using Pkg adding following test_args:","category":"page"},{"location":"usage/runtests/#For-CUDA-backend-(Nvidia-GPUs):","page":"Running tests","title":"For CUDA backend (Nvidia GPUs):","text":"","category":"section"},{"location":"usage/runtests/","page":"Running tests","title":"Running tests","text":"using Pkg\nPkg.test(\"Chmy\"; test_args=[\"--backend=CUDA\"])","category":"page"},{"location":"usage/runtests/#For-ROC-backend-(AMD-GPUs):","page":"Running tests","title":"For ROC backend (AMD GPUs):","text":"","category":"section"},{"location":"usage/runtests/","page":"Running tests","title":"Running tests","text":"using Pkg\nPkg.test(\"Chmy\"; test_args=[\"--backend=AMDGPU\"])","category":"page"},{"location":"#Chmy.jl","page":"Home","title":"Chmy.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Chmy.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Information about the GPU4GEO project can be found on the GPU4GEO website.","category":"page"},{"location":"#Doc-content","page":"Home","title":"Doc content","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Usage information\nAPI reference","category":"page"}]
}
